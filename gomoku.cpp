#include <algorithm>
#include <array>
#include <atomic>
#include <chrono>
#include <cctype>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <map>
#include <memory>
#include <mutex>
#include <numeric>
#include <random>
#include <set>
#include <sstream>
#include <string>
#include <thread>
#include <tuple>
#include <utility>
#include <vector>
#if defined(__BMI2__)
#include <immintrin.h>
#endif
#if defined(_WIN32)
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#else
#include <errno.h>
#include <sys/select.h>
#include <termios.h>
#include <unistd.h>
#endif
using namespace std;
static constexpr int n=15;
static constexpr int eempt=0;
static constexpr int black=1;
static constexpr int white=-1;
static constexpr int winsc=10'000'000;
static constexpr int inf=1'000'000'000;
static inline bool inb(int r,int c){
    return(r>=0&&r<n&&c>=0&&c<n);
}
struct move0{
    int r=0,c=0;
    int h=0;
};
struct srchl{
    int timms=10'000;
    int threa=0;
    size_t tt_mb=64;
    bool shatt=true;
    bool usepe=true;
    bool usenu=true;
    bool usedf=true;
    bool usebo=true;
    int boply=6;
    bool bosym=true;
};
struct srchs{
    uint64_t nodes=0;
    uint64_t qnode=0;
};
namespace shared0{
    static bool inied=false;
    static uint64_t zobri[n][n][2];
    static uint64_t zside;
    static constexpr int linro=n;
    static constexpr int linco=n;
    static constexpr int lindi=2*n-1;
    static constexpr int linan=2*n-1;
    static constexpr int libar=0;
    static constexpr int libac=libar+linro;
    static constexpr int libad=libac+linco;
    static constexpr int libaa=libad+lindi;
    static constexpr int lincn=libaa+linan;
    static constexpr int winsi=2187;
    static array<vector<pair<uint8_t,uint8_t>>,lincn>lince;
    static array<int,7>pow3;
    static array<int,winsi>win7;
    static int digst[2*n-1],diags[2*n-1],digl[2*n-1];
    static int ansta[2*n-1],antis[2*n-1],anlen[2*n-1];
    static inline int digid(int r,int c){
        return r-c+(n-1);
    }
    static inline int anidx(int r,int c){
        return r+c;
    }
    static inline int digpo(int r,int d){
        return r-digst[d];
    }
    static inline int anpos(int r,int s){
        return r-ansta[s];
    }
    static void inion(){
        if(inied){
            return;
        }
        inied=true;
        mt19937_64 rng(0xBADC0FFEEULL);
        for(int r=0;r<n;r++){
            for(int c=0;c<n;c++){
                zobri[r][c][0]=rng();
                zobri[r][c][1]=rng();
            }
        }
        zside=rng();
        for(int i=0;i<lincn;i++){
            lince[i].clear();
        }
        for(int r=0;r<n;r++){
            int id=libar+r;
            lince[id].reserve(n);
            for(int c=0;c<n;c++){
                lince[id].push_back({(uint8_t)r,(uint8_t)c});
            }
        }
        for(int c=0;c<n;c++){
            int id=libac+c;
            lince[id].reserve(n);
            for(int r=0;r<n;r++){
                lince[id].push_back({(uint8_t)r,(uint8_t)c});
            }
        }
        for(int d=0;d<lindi;d++){
            int diff=d-(n-1);
            int r=max(0,diff);
            int c=max(0,-diff);
            int id=libad+d;
            while(inb(r,c)){
                lince[id].push_back({(uint8_t)r,(uint8_t)c});
                r++;
                c++;
            }
        }
        for(int s=0;s<linan;s++){
            int r=max(0,s-(n-1));
            int c=min(n-1,s);
            int id=libaa+s;
            while(inb(r,c)){
                lince[id].push_back({(uint8_t)r,(uint8_t)c});
                r++;
                c--;
            }
        }
        pow3[0]=1;
        for(int i=1;i<7;i++){
            pow3[i]=pow3[i-1]*3;
        }
        static const vector<pair<string,int>>p0={{"11111",winsc},{"011110",1'700'000},{"211110",300'000},{"011112",300'000},{"11011",240'000},{"10111",240'000},{"11101",240'000},{"0110110",180'000},{"0101110",180'000},{"0111010",180'000},{"01110",22'000},{"21110",8'000},{"01112",8'000},{"010110",7'500},{"011010",7'500},{"0011100",5'500},{"0010110",5'500},{"0110100",5'500},{"001110",2'200},{"011100",2'200},{"00110",520},{"01100",520},{"01010",320},{"010010",160},};
        for(int code=0;code<winsi;code++){
            int tmp=code;
            int d[7];
            for(int i=0;i<7;i++){
                d[i]=tmp%3;
                tmp/=3;
            }
            int total=0;
            for(auto&pw:p0){
                const string&pat=pw.first;
                int w=pw.second;
                int l0=(int)pat.size();
                for(int off=0;off+l0<=7;off++){
                    bool ok=true;
                    for(int j=0;j<l0;j++){
                        int want=pat[j]-'0';
                        if(d[off+j]!=want){
                            ok=false;
                            break;
                        }
                    }
                    if(ok){
                        total+=w;
                        if(total>=winsc){
                            total=winsc;
                            break;
                        }
                    }
                }
                if(total>=winsc){
                    break;
                }
            }
            win7[code]=total;
        }
        for(int d=0;d<2*n-1;d++){
            int diff=d-(n-1);
            int sr=max(0,diff);
            int sc=max(0,-diff);
            digst[d]=sr;
            diags[d]=sc;
            int len=0;
            int r=sr,c=sc;
            while(inb(r,c)){
                len++;
                r++;
                c++;
            }
            digl[d]=len;
        }
        for(int s=0;s<2*n-1;s++){
            int sr=max(0,s-(n-1));
            int sc=min(n-1,s);
            ansta[s]=sr;
            antis[s]=sc;
            int len=0;
            int r=sr,c=sc;
            while(inb(r,c)){
                len++;
                r++;
                c--;
            }
            anlen[s]=len;
        }
    }
}
class tttab{
    public:
    static constexpr int ways=4;
    struct slot{
        std::atomic<uint64_t>meta{0};
        std::atomic<uint64_t>data{0};
    };
    struct bkt{
        slot s[ways];
    };
    void inimb(size_t mb){
        size_t bytes=mb*1024ULL*1024ULL;
        size_t bkts=std::max<size_t>(1,bytes/sizeof(bkt));
        size_t pow2=1;
        while(pow2<bkts){
            pow2<<=1;
        }
        if(pow2>(1u<<24)){
            pow2=(1u<<24);
        }
        tabpt.reset(new bkt[pow2]);
        bktcn=pow2;
        mask=pow2-1;
        gener=1;
        for(size_t bi=0;bi<bktcn;++bi){
            for(int i=0;i<ways;i++){
                tabpt[bi].s[i].meta.store(0,std::memory_order_relaxed);
                tabpt[bi].s[i].data.store(0,std::memory_order_relaxed);
            }
        }
    }
    uint16_t newsr(){
        uint16_t g=(uint16_t)(gener+1);
        if(g==0){
            g=1;
        }
        gener=g;
        return gener;
    }
    void seusp(bool on){
        usepe=on&&bmrts();
    }
    bool geusp() const{
        return usepe;
    }
    inline bool looku(uint64_t key,int depth,int&alpha,int&beta,int&outva,uint8_t&outr,uint8_t&outc) const{
        const uint32_t lock=(uint32_t)(key>>32);
        const bkt&b=tabpt[index(key)];
        int bsdes=-32768;
        uint64_t bsdat=0;
        bool found=false;
        for(int i=0;i<ways;i++){
            const slot&s=b.s[i];
            uint64_t m1=s.meta.load(std::memory_order_acquire);
            uint32_t l=(uint32_t)(m1>>32);
            int d=unpde(m1);
            if(d<=-32768){
                continue;
            }
            if(l!=lock){
                continue;
            }
            uint64_t d1=s.data.load(std::memory_order_relaxed);
            uint64_t m2=s.meta.load(std::memory_order_acquire);
            if(m1!=m2){
                continue;
            }
            if(d>bsdes){
                bsdes=d;
                bsdat=d1;
                found=true;
            }
            if(d>=depth){
                int v=(int32_t)(uint32_t)(d1>>32);
                uint8_t flag=(uint8_t)((d1>>24)&0xFF);
                outr=(uint8_t)((d1>>16)&0xFF);
                outc=(uint8_t)((d1>>8)&0xFF);
                if(flag==0){
                    outva=v;
                    return true;
                }
                if(flag==1){
                    alpha=std::max(alpha,v);
                }else{
                    if(flag==2){
                        beta=std::min(beta,v);
                    }
                }
                if(alpha>=beta){
                    outva=v;
                    return true;
                }
            }
        }
        if(found){
            outr=(uint8_t)((bsdat>>16)&0xFF);
            outc=(uint8_t)((bsdat>>8)&0xFF);
        }
        return false;
    }
    inline void store(uint64_t key,int depth,int value,uint8_t flag,uint8_t br,uint8_t bc,uint16_t curge){
        const uint32_t lock=(uint32_t)(key>>32);
        bkt&b=tabpt[index(key)];
        int match=-1;
        int victi=0;
        int vvict=std::numeric_limits<int>::min();
        for(int i=0;i<ways;i++){
            uint64_t m=b.s[i].meta.load(std::memory_order_relaxed);
            int d=unpde(m);
            uint32_t l=(uint32_t)(m>>32);
            uint16_t gen=(uint16_t)(m&0xFFFF);
            if(d<=-32768){
                victi=i;
                vvict=std::numeric_limits<int>::max();
                break;
            }
            if(l==lock){
                match=i;
                victi=i;
                break;
            }
            uint16_t age=(uint16_t)(curge-gen);
            uint64_t dat=b.s[i].data.load(std::memory_order_relaxed);
            uint8_t eflag=(uint8_t)((dat>>24)&0xFF);
            bool exact=(eflag==0);
            int rep=(int)age*1024+(32767-d)*4;
            if(exact){
                rep-=2048;
            }
            if(age==0){
                rep-=512;
            }
            if(rep>vvict){
                vvict=rep;
                victi=i;
            }
        }
        slot&s=b.s[victi];
        uint64_t oldm=s.meta.load(std::memory_order_relaxed);
        int oldd=unpde(oldm);
        uint16_t oldg=(uint16_t)(oldm&0xFFFF);
        uint64_t olddp=s.data.load(std::memory_order_relaxed);
        uint8_t oldfl=(uint8_t)((olddp>>24)&0xFF);
        bool oldex=(oldfl==0);
        if(match<0){
            if(oldg==curge){
                if(oldd>depth+1){
                    return;
                }
                if(oldex&&flag!=0&&oldd>=depth){
                    return;
                }
            }
        }else{
            if(oldg==curge){
                bool upgra=(flag==0&&oldfl!=0);
                if(!upgra&&oldd>depth){
                    return;
                }
                if(!upgra&&oldd==depth&&oldex&&flag!=0){
                    return;
                }
            }
        }
        uint64_t dpack=pacda(value,flag,br,bc);
        s.data.store(dpack,std::memory_order_relaxed);
        uint64_t mpack=pacme(lock,depth,curge);
        s.meta.store(mpack,std::memory_order_release);
    }
    inline bool getbs(uint64_t key,uint8_t&br,uint8_t&bc) const{
        const uint32_t lock=(uint32_t)(key>>32);
        const bkt&b=tabpt[index(key)];
        int bsdep=-32768;
        uint8_t bestr=255,bestc=255;
        for(int i=0;i<ways;i++){
            const slot&s=b.s[i];
            uint64_t m1=s.meta.load(std::memory_order_acquire);
            uint32_t l=(uint32_t)(m1>>32);
            int d=unpde(m1);
            if(d<=-32768||l!=lock){
                continue;
            }
            uint64_t d1=s.data.load(std::memory_order_relaxed);
            uint64_t m2=s.meta.load(std::memory_order_acquire);
            if(m1!=m2){
                continue;
            }
            if(d>bsdep){
                bsdep=d;
                bestr=(uint8_t)((d1>>16)&0xFF);
                bestc=(uint8_t)((d1>>8)&0xFF);
            }
        }
        if(bsdep>-32768&&bestr!=255&&bestc!=255){
            br=bestr;
            bc=bestc;
            return true;
        }
        return false;
    }
    private:
    std::unique_ptr<bkt[]>tabpt;
    size_t bktcn=0;
    size_t mask=0;
    uint16_t gener=1;
    bool usepe=false;
    static constexpr uint64_t pexms=0xF0F0F0F0F0F0F0F0ULL;
    inline size_t index(uint64_t key) const{
#if defined(__BMI2__)
        if(usepe){
            uint64_t x=_pext_u64(key,pexms);
            return(size_t)x&mask;
        }
#endif
        return(size_t)key&mask;
    }
    static inline uint16_t padeu(int depth){
        if(depth<-32768){
            depth=-32768;
        }
        if(depth>32767){
            depth=32767;
        }
        return(uint16_t)(depth+32768);
    }
    static inline int unpde(uint64_t meta){
        uint16_t du=(uint16_t)((meta>>16)&0xFFFF);
        return(int)du-32768;
    }
    static inline uint64_t pacme(uint32_t lock,int depth,uint16_t gen){
        uint64_t m=((uint64_t)lock<<32);
        m|=((uint64_t)padeu(depth)<<16);
        m|=(uint64_t)gen;
        return m;
    }
    static inline uint64_t pacda(int value,uint8_t flag,uint8_t br,uint8_t bc){
        uint64_t v=(uint64_t)(uint32_t)value;
        uint64_t d=(v<<32);
        d|=((uint64_t)flag<<24);
        d|=((uint64_t)br<<16);
        d|=((uint64_t)bc<<8);
        return d;
    }
    static inline bool bmrts(){
#if defined(__BMI2__)
        static int cached=-1;
        if(cached!=-1){
            return cached==1;
        }
#if defined(__x86_64__) || defined(__i386__) || defined(_M_X64) || defined(_M_IX86)
#if defined(__GNUC__) || defined(__clang__)
        cached=__builtin_cpu_supports("bmi2")?1:0;
#else
        cached=0;
#endif
#else
        cached=0;
#endif
        return cached==1;
#else
        return false;
#endif
    }
};
namespace btnbk{
    static constexpr uint8_t maxpl=6;
    struct entry{
        uint16_t pfxof;
        uint8_t pfxle;
        uint16_t movof;
        uint8_t movle;
    };
    static const uint8_t pfxpo[6418]={
        112,112,97,112,98,112,97,37,112,97,52,112,97,53,112,97,54,112,97,55,112,97,56,112,97,67,112,97,68,112,97,69,112,97,70,
        112,97,82,112,97,83,112,97,84,112,97,85,112,97,86,112,97,98,112,97,99,112,97,100,112,97,101,112,97,113,112,97,114,112,
        97,115,112,97,116,112,97,127,112,97,128,112,97,129,112,97,130,112,97,131,112,97,142,112,97,143,112,97,144,112,97,145,
        112,97,146,112,97,157,112,97,158,112,97,159,112,97,160,112,97,161,112,97,172,112,97,173,112,97,174,112,97,175,112,97,
        176,112,98,71,112,98,84,112,98,85,112,98,86,112,98,99,112,98,100,112,98,101,112,98,113,112,97,52,83,112,97,52,98,112,97,
        52,128,112,97,53,81,112,97,53,83,112,97,53,98,112,97,54,81,112,97,54,96,112,97,54,126,112,97,67,68,112,97,67,81,112,97,
        67,82,112,97,67,83,112,97,67,84,112,97,67,98,112,97,67,99,112,97,67,111,112,97,67,113,112,97,67,128,112,97,68,66,112,97,
        68,67,112,97,68,81,112,97,68,82,112,97,68,83,112,97,68,84,112,97,68,95,112,97,68,96,112,97,68,98,112,97,68,99,112,97,68,
        111,112,97,68,113,112,97,68,114,112,97,68,126,112,97,68,127,112,97,68,128,112,97,68,129,112,97,69,81,112,97,69,83,112,
        97,69,84,112,97,69,96,112,97,69,98,112,97,69,128,112,97,70,98,112,97,82,67,112,97,82,68,112,97,82,83,112,97,82,84,112,
        97,82,98,112,97,82,99,112,97,82,113,112,97,82,127,112,97,82,128,112,97,83,65,112,97,83,66,112,97,83,67,112,97,83,68,112,
        97,83,69,112,97,83,80,112,97,83,81,112,97,83,82,112,97,83,84,112,97,83,96,112,97,83,98,112,97,83,99,112,97,83,100,112,
        97,83,111,112,97,83,113,112,97,83,114,112,97,83,126,112,97,83,127,112,97,83,128,112,97,83,129,112,97,84,65,112,97,84,66,
        112,97,84,67,112,97,84,68,112,97,84,69,112,97,84,70,112,97,84,80,112,97,84,81,112,97,84,82,112,97,84,83,112,97,84,85,
        112,97,84,95,112,97,84,96,112,97,84,98,112,97,84,99,112,97,84,100,112,97,84,110,112,97,84,111,112,97,84,113,112,97,84,
        114,112,97,84,115,112,97,84,125,112,97,84,126,112,97,84,127,112,97,84,128,112,97,84,129,112,97,85,68,112,97,85,81,112,
        97,85,83,112,97,85,96,112,97,85,99,112,97,85,111,112,97,85,113,112,97,85,114,112,97,85,126,112,97,98,65,112,97,98,80,
        112,97,98,81,112,97,98,82,112,97,98,83,112,97,98,84,112,97,98,95,112,97,98,96,112,97,98,99,112,97,98,110,112,97,98,111,
        112,97,98,113,112,97,98,114,112,97,98,125,112,97,98,126,112,97,98,127,112,97,98,128,112,97,98,129,112,97,98,140,112,97,
        98,141,112,97,98,142,112,97,98,143,112,97,98,144,112,97,98,145,112,97,99,81,112,97,99,82,112,97,99,83,112,97,99,84,112,
        97,99,85,112,97,99,95,112,97,99,96,112,97,99,98,112,97,99,100,112,97,99,111,112,97,99,113,112,97,99,114,112,97,99,115,
        112,97,99,126,112,97,99,127,112,97,99,128,112,97,99,129,112,97,99,130,112,97,100,81,112,97,100,83,112,97,100,84,112,97,
        100,96,112,97,100,98,112,97,100,111,112,97,100,113,112,97,100,114,112,97,100,126,112,97,100,128,112,97,100,130,112,97,
        113,80,112,97,113,81,112,97,113,82,112,97,113,83,112,97,113,84,112,97,113,95,112,97,113,98,112,97,113,99,112,97,113,110,
        112,97,113,111,112,97,113,114,112,97,113,115,112,97,113,125,112,97,113,126,112,97,113,127,112,97,113,128,112,97,113,129,
        112,97,113,140,112,97,113,141,112,97,113,142,112,97,113,143,112,97,113,144,112,97,114,65,112,97,114,66,112,97,114,67,
        112,97,114,68,112,97,114,69,112,97,114,80,112,97,114,81,112,97,114,82,112,97,114,83,112,97,114,84,112,97,114,85,112,97,
        114,95,112,97,114,96,112,97,114,98,112,97,114,99,112,97,114,100,112,97,114,110,112,97,114,111,112,97,114,113,112,97,114,
        115,112,97,114,125,112,97,114,126,112,97,114,127,112,97,114,128,112,97,114,129,112,97,114,130,112,97,114,141,112,97,114,
        142,112,97,114,143,112,97,114,144,112,97,115,81,112,97,115,83,112,97,115,111,112,97,115,114,112,97,115,129,112,97,116,
        96,112,97,116,111,112,97,127,67,112,97,127,68,112,97,127,69,112,97,127,82,112,97,127,83,112,97,127,84,112,97,127,98,112,
        97,127,99,112,97,127,113,112,97,127,114,112,97,127,128,112,97,127,129,112,97,127,142,112,97,127,143,112,97,127,144,112,
        97,127,157,112,97,127,158,112,97,127,159,112,97,128,81,112,97,128,83,112,97,128,96,112,97,128,98,112,97,128,110,112,97,
        128,111,112,97,128,113,112,97,128,114,112,97,128,126,112,97,128,127,112,97,128,142,112,97,128,143,112,97,128,144,112,97,
        129,65,112,97,129,66,112,97,129,67,112,97,129,68,112,97,129,69,112,97,129,80,112,97,129,81,112,97,129,82,112,97,129,83,
        112,97,129,84,112,97,129,95,112,97,129,96,112,97,129,98,112,97,129,99,112,97,129,100,112,97,129,110,112,97,129,111,112,
        97,129,113,112,97,129,114,112,97,129,115,112,97,129,125,112,97,129,126,112,97,129,127,112,97,129,128,112,97,129,130,112,
        97,129,141,112,97,129,142,112,97,129,143,112,97,129,144,112,97,129,145,112,97,130,96,112,97,142,67,112,97,142,68,112,97,
        142,69,112,97,142,82,112,97,142,83,112,97,142,84,112,97,142,98,112,97,142,99,112,97,142,113,112,97,142,114,112,97,142,
        127,112,97,142,128,112,97,142,129,112,97,142,143,112,97,142,144,112,97,142,157,112,97,142,158,112,97,142,159,112,97,142,
        172,112,97,142,173,112,97,142,174,112,97,143,80,112,97,143,81,112,97,143,82,112,97,143,83,112,97,143,84,112,97,143,95,
        112,97,143,96,112,97,143,98,112,97,143,99,112,97,143,110,112,97,143,111,112,97,143,113,112,97,143,114,112,97,143,125,
        112,97,143,126,112,97,143,127,112,97,143,128,112,97,143,129,112,97,143,140,112,97,143,141,112,97,143,142,112,97,143,144,
        112,97,143,157,112,97,144,81,112,97,144,83,112,97,144,96,112,97,144,98,112,97,144,111,112,97,144,113,112,97,144,126,112,
        97,144,128,112,97,146,96,112,97,157,83,112,97,158,83,112,97,158,98,112,98,84,53,112,98,84,67,112,98,84,68,112,98,84,81,
        112,98,84,82,112,98,84,83,112,98,84,96,112,98,85,53,112,98,85,67,112,98,85,68,112,98,85,69,112,98,85,81,112,98,85,82,
        112,98,85,83,112,98,85,95,112,98,85,96,112,98,85,97,112,98,85,99,112,98,85,100,112,98,85,101,112,98,85,111,112,98,85,
        113,112,98,85,114,112,98,85,115,112,98,85,127,112,98,85,128,112,98,85,130,112,98,85,143,112,98,86,99,112,98,99,66,112,
        98,99,67,112,98,99,68,112,98,99,69,112,98,99,70,112,98,99,81,112,98,99,82,112,98,99,83,112,98,99,84,112,98,99,85,112,98,
        99,96,112,98,99,97,112,98,99,100,112,98,99,111,112,98,99,113,112,98,99,114,112,98,99,115,112,98,99,126,112,98,99,127,
        112,98,99,128,112,98,99,129,112,98,99,130,112,98,100,81,112,98,100,82,112,98,100,83,112,98,100,84,112,98,100,85,112,98,
        100,96,112,98,100,97,112,98,100,111,112,98,100,113,112,98,100,114,112,98,100,115,112,98,100,116,112,98,100,127,112,98,
        100,128,112,98,100,129,112,98,100,130,112,98,100,142,112,98,100,143,112,98,101,82,112,98,113,80,112,98,113,81,112,98,
        113,82,112,98,113,83,112,98,113,84,112,98,113,85,112,98,113,95,112,98,113,96,112,98,113,97,112,98,113,99,112,98,113,100,
        112,98,113,110,112,98,113,111,112,98,113,114,112,98,113,115,112,98,113,125,112,98,113,126,112,98,113,127,112,97,52,83,
        66,112,97,52,83,69,112,97,52,83,80,112,97,52,83,84,112,97,52,98,83,112,97,52,98,96,112,97,52,98,99,112,97,52,128,98,112,
        97,53,81,96,112,97,53,81,113,112,97,54,81,98,112,97,54,96,98,112,97,54,126,53,112,97,54,126,83,112,97,54,126,114,112,97,
        67,68,96,112,97,67,68,111,112,97,67,81,65,112,97,67,81,80,112,97,67,81,84,112,97,67,81,95,112,97,67,81,96,112,97,67,81,
        98,112,97,67,81,111,112,97,67,81,113,112,97,67,82,68,112,97,67,82,98,112,97,67,82,113,112,97,67,83,68,112,97,67,83,81,
        112,97,67,83,82,112,97,67,83,95,112,97,67,83,128,112,97,67,84,81,112,97,67,84,96,112,97,67,84,111,112,97,67,98,81,112,
        97,67,98,96,112,97,67,98,99,112,97,67,99,80,112,97,67,99,81,112,97,67,99,96,112,97,67,111,83,112,97,67,113,66,112,97,67,
        113,81,112,97,67,113,96,112,97,67,128,81,112,97,67,128,83,112,97,68,81,113,112,97,68,83,81,112,97,68,83,96,112,97,68,84,
        80,112,97,68,84,81,112,97,68,84,96,112,97,68,84,110,112,97,68,84,111,112,97,68,95,96,112,97,68,95,98,112,97,68,96,81,
        112,97,68,96,84,112,97,68,96,95,112,97,68,96,98,112,97,68,98,96,112,97,68,98,99,112,97,68,99,84,112,97,68,113,81,112,97,
        68,113,96,112,97,69,81,96,112,97,69,81,99,112,97,69,81,113,112,97,69,81,114,112,97,69,81,126,112,97,69,84,96,112,97,69,
        96,68,112,97,69,96,81,112,97,69,98,81,112,97,69,98,96,112,97,69,98,99,112,97,69,98,126,112,97,69,128,67,112,97,70,98,83,
        112,97,70,98,96,112,97,70,98,99,112,97,82,67,84,112,97,82,67,98,112,97,82,67,114,112,97,82,67,128,112,97,82,68,80,112,
        97,82,68,84,112,97,82,68,96,112,97,82,68,98,112,97,82,83,81,112,97,82,83,95,112,97,82,83,96,112,97,82,83,98,112,97,82,
        83,99,112,97,82,83,111,112,97,82,83,114,112,97,82,83,128,112,97,82,84,80,112,97,82,84,96,112,97,82,84,110,112,97,82,84,
        111,112,97,82,98,65,112,97,82,98,67,112,97,82,98,68,112,97,82,98,80,112,97,82,98,84,112,97,82,98,95,112,97,82,98,96,112,
        97,82,98,99,112,97,82,98,100,112,97,82,98,110,112,97,82,98,113,112,97,82,98,125,112,97,82,98,126,112,97,82,98,128,112,
        97,82,99,96,112,97,82,99,98,112,97,82,99,111,112,97,82,113,96,112,97,82,113,129,112,97,82,127,84,112,97,83,69,98,112,97,
        83,81,66,112,97,83,81,67,112,97,83,81,95,112,97,83,81,96,112,97,83,81,99,112,97,83,81,128,112,97,83,81,129,112,97,83,82,
        114,112,97,83,84,96,112,97,83,84,99,112,97,83,84,100,112,97,83,84,111,112,97,83,84,113,112,97,83,84,128,112,97,83,84,
        129,112,97,83,96,66,112,97,83,96,68,112,97,83,96,84,112,97,83,96,111,112,97,83,96,126,112,97,83,98,82,112,97,83,98,96,
        112,97,83,98,110,112,97,83,98,111,112,97,83,98,115,112,97,83,98,127,112,97,83,99,66,112,97,83,99,80,112,97,83,99,85,112,
        97,83,99,98,112,97,83,99,111,112,97,83,99,113,112,97,83,113,81,112,97,83,113,82,112,97,83,113,96,112,97,83,113,98,112,
        97,83,113,99,112,97,83,113,110,112,97,83,113,111,112,97,83,113,114,112,97,83,113,126,112,97,83,113,128,112,97,83,113,
        129,112,97,83,114,80,112,97,83,114,81,112,97,83,114,96,112,97,83,114,98,112,97,83,114,99,112,97,83,114,128,112,97,83,
        126,114,112,97,83,126,115,112,97,83,127,82,112,97,83,129,68,112,97,83,129,80,112,97,83,129,111,112,97,83,129,113,112,97,
        83,129,126,112,97,83,129,128,112,97,84,65,98,112,97,84,66,98,112,97,84,83,96,112,97,84,96,113,112,97,84,96,114,112,97,
        84,98,66,112,97,84,98,67,112,97,84,98,68,112,97,84,98,69,112,97,84,98,70,112,97,84,98,80,112,97,84,98,81,112,97,84,98,
        82,112,97,84,98,83,112,97,84,98,95,112,97,84,98,96,112,97,84,98,99,112,97,84,98,100,112,97,84,98,111,112,97,84,98,113,
        112,97,84,98,114,112,97,84,98,115,112,97,84,98,127,112,97,84,98,128,112,97,84,98,129,112,97,84,98,130,112,97,84,111,113,
        112,97,84,113,81,112,97,84,113,98,112,97,84,113,128,112,97,84,126,83,112,97,84,126,85,112,97,84,126,99,112,97,85,83,68,
        112,97,85,83,115,112,97,85,99,98,112,97,85,99,100,112,97,85,113,129,112,97,85,114,99,112,97,85,126,83,112,97,85,126,100,
        112,97,85,126,115,112,97,98,81,113,112,97,98,81,126,112,97,98,81,129,112,97,98,84,69,112,97,98,84,110,112,97,98,84,111,
        112,97,98,84,126,112,97,98,96,84,112,97,98,96,126,112,97,98,111,83,112,97,98,111,126,112,97,98,113,68,112,97,98,113,85,
        112,97,98,113,100,112,97,98,113,111,112,97,98,113,115,112,97,98,113,116,112,97,98,113,126,112,97,98,113,127,112,97,98,
        113,128,112,97,98,113,129,112,97,98,113,140,112,97,98,113,141,112,97,98,113,142,112,97,98,113,143,112,97,98,113,144,112,
        97,98,113,145,112,97,98,113,146,112,97,98,113,160,112,97,98,126,68,112,97,98,126,81,112,97,98,126,83,112,97,98,126,84,
        112,97,98,126,96,112,97,98,126,99,112,97,98,126,113,112,97,98,126,114,112,97,98,126,115,112,97,98,126,128,112,97,98,127,
        111,112,97,98,127,113,112,97,98,127,114,112,97,98,127,126,112,97,98,128,67,112,97,98,128,68,112,97,98,128,83,112,97,98,
        128,84,112,97,98,128,127,112,97,98,129,82,112,97,98,129,113,112,97,98,129,126,112,97,98,129,128,112,97,98,141,84,112,97,
        98,141,114,112,97,98,142,84,112,97,98,142,113,112,97,98,143,84,112,97,98,143,114,112,97,99,81,98,112,97,99,81,111,112,
        97,99,81,113,112,97,99,81,114,112,97,99,83,68,112,97,99,83,69,112,97,99,83,84,112,97,99,83,111,112,97,99,83,114,112,97,
        99,83,128,112,97,99,84,113,112,97,99,84,128,112,97,99,96,84,112,97,99,96,111,112,97,99,96,113,112,97,99,98,113,112,97,
        99,111,67,112,97,99,111,68,112,97,99,111,69,112,97,99,111,80,112,97,99,111,81,112,97,99,111,83,112,97,99,111,84,112,97,
        99,111,96,112,97,99,111,98,112,97,99,111,113,112,97,99,111,114,112,97,99,111,125,112,97,99,111,126,112,97,99,111,127,
        112,97,99,111,128,112,97,99,111,129,112,97,99,113,81,112,97,99,113,98,112,97,99,113,129,112,97,99,114,81,112,97,99,114,
        83,112,97,99,114,96,112,97,99,114,113,112,97,99,114,126,112,97,99,114,127,112,97,99,114,128,112,97,99,128,126,112,97,99,
        129,83,112,97,99,129,98,112,97,99,129,113,112,97,100,81,113,112,97,100,81,128,112,97,100,84,113,112,97,100,84,114,112,
        97,100,84,115,112,97,100,84,128,112,97,100,84,130,112,97,100,84,144,112,97,100,96,68,112,97,100,96,81,112,97,100,96,82,
        112,97,100,96,84,112,97,100,96,95,112,97,100,96,98,112,97,100,98,65,112,97,100,98,83,112,97,100,98,84,112,97,100,98,96,
        112,97,100,98,99,112,97,100,98,113,112,97,100,98,114,112,97,100,98,126,112,97,100,98,128,112,97,100,111,68,112,97,100,
        111,84,112,97,100,111,96,112,97,100,114,83,112,97,100,114,84,112,97,100,114,129,112,97,100,114,130,112,97,100,126,68,
        112,97,100,128,84,112,97,100,128,116,112,97,113,98,82,112,97,113,98,95,112,97,113,98,96,112,97,113,98,110,112,97,113,98,
        111,112,97,113,98,142,112,97,113,99,98,112,97,113,99,128,112,97,113,111,83,112,97,113,111,95,112,97,113,111,96,112,97,
        113,111,98,112,97,113,111,99,112,97,113,111,110,112,97,113,111,127,112,97,113,111,128,112,97,113,111,141,112,97,113,114,
        83,112,97,113,114,96,112,97,113,114,98,112,97,113,114,99,112,97,113,114,111,112,97,113,114,128,112,97,113,127,114,112,
        97,114,81,98,112,97,114,83,84,112,97,114,83,98,112,97,114,83,100,112,97,114,83,111,112,97,114,83,113,112,97,114,83,128,
        112,97,114,84,144,112,97,114,96,83,112,97,114,96,98,112,97,114,96,113,112,97,114,96,126,112,97,114,96,129,112,97,114,98,
        144,112,97,114,111,83,112,97,114,111,84,112,97,114,111,96,112,97,114,111,98,112,97,114,111,99,112,97,114,111,125,112,97,
        114,111,126,112,97,114,111,127,112,97,114,111,129,112,97,114,111,142,112,97,114,111,143,112,97,114,113,83,112,97,114,
        113,128,112,97,114,113,129,112,97,114,113,142,112,97,114,113,143,112,97,114,126,113,112,97,114,126,128,112,97,114,128,
        83,112,97,114,128,98,112,97,114,128,129,112,97,114,129,83,112,97,114,129,96,112,97,114,129,111,112,97,115,81,99,112,97,
        115,81,113,112,97,115,83,69,112,97,115,83,100,112,97,115,83,111,112,97,115,111,70,112,97,115,111,81,112,97,115,111,83,
        112,97,115,111,95,112,97,115,111,96,112,97,115,111,98,112,97,115,111,99,112,97,115,111,113,112,97,115,111,125,112,97,
        115,111,126,112,97,115,111,127,112,97,115,114,130,112,97,115,129,144,112,97,116,96,95,112,97,116,111,81,112,97,116,111,
        83,112,97,116,111,95,112,97,116,111,96,112,97,116,111,126,112,97,127,69,111,112,97,127,82,99,112,97,127,82,113,112,97,
        127,82,128,112,97,127,83,81,112,97,127,83,82,112,97,127,83,95,112,97,127,83,96,112,97,127,83,98,112,97,127,83,110,112,
        97,127,83,111,112,97,127,83,113,112,97,127,83,114,112,97,127,83,125,112,97,127,83,126,112,97,127,83,128,112,97,127,83,
        129,112,97,127,83,143,112,97,127,98,83,112,97,127,98,96,112,97,127,98,99,112,97,127,98,111,112,97,127,98,113,112,97,127,
        98,128,112,97,127,98,129,112,97,127,98,143,112,97,127,113,81,112,97,127,113,129,112,97,127,114,95,112,97,127,114,96,112,
        97,127,114,98,112,97,127,114,111,112,97,127,114,129,112,97,127,114,143,112,97,127,128,99,112,97,127,128,143,112,97,127,
        142,82,112,97,127,142,83,112,97,127,142,98,112,97,127,142,99,112,97,127,142,113,112,97,127,142,114,112,97,127,142,128,
        112,97,127,142,129,112,97,127,142,143,112,97,127,142,158,112,97,127,143,96,112,97,127,143,111,112,97,127,143,113,112,97,
        127,143,126,112,97,127,143,128,112,97,127,143,141,112,97,127,143,157,112,97,127,143,158,112,97,128,96,66,112,97,128,96,
        67,112,97,128,96,80,112,97,128,96,81,112,97,128,96,82,112,97,128,96,83,112,97,128,96,84,112,97,128,96,95,112,97,128,96,
        98,112,97,128,96,99,112,97,128,96,110,112,97,128,96,111,112,97,128,96,113,112,97,128,96,114,112,97,128,96,125,112,97,
        128,96,126,112,97,128,96,127,112,97,128,96,130,112,97,128,96,140,112,97,128,96,142,112,97,128,96,143,112,97,128,96,145,
        112,97,128,96,158,112,97,128,96,159,112,97,128,96,160,112,97,128,111,125,112,97,128,111,126,112,97,128,143,96,112,97,
        128,144,113,112,97,129,81,114,112,97,129,81,128,112,97,129,81,144,112,97,129,82,143,112,97,129,83,69,112,97,129,83,111,
        112,97,129,83,115,112,97,129,83,126,112,97,129,83,128,112,97,129,96,95,112,97,129,96,98,112,97,129,96,99,112,97,129,96,
        125,112,97,129,96,126,112,97,129,96,128,112,97,129,98,99,112,97,129,98,115,112,97,129,98,126,112,97,129,98,128,112,97,
        129,98,143,112,97,129,99,98,112,97,129,99,111,112,97,129,99,128,112,97,129,111,81,112,97,129,111,83,112,97,129,111,84,
        112,97,129,111,95,112,97,129,111,96,112,97,129,111,98,112,97,129,111,99,112,97,129,111,113,112,97,129,111,114,112,97,
        129,111,125,112,97,129,111,126,112,97,129,111,127,112,97,129,111,143,112,97,129,114,98,112,97,129,114,126,112,97,129,
        114,143,112,97,129,126,96,112,97,129,126,114,112,97,129,126,157,112,97,129,128,114,112,97,129,128,143,112,97,129,130,
        144,112,97,129,141,143,112,97,129,141,144,112,97,129,143,98,112,97,130,96,81,112,97,130,96,82,112,97,130,96,95,112,97,
        130,96,98,112,97,130,96,111,112,97,142,83,65,112,97,142,83,66,112,97,142,83,67,112,97,142,83,68,112,97,142,83,69,112,97,
        142,83,80,112,97,142,83,81,112,97,142,83,82,112,97,142,83,84,112,97,142,83,94,112,97,142,83,95,112,97,142,83,96,112,97,
        142,83,98,112,97,142,83,99,112,97,142,83,100,112,97,142,83,110,112,97,142,83,111,112,97,142,83,113,112,97,142,83,114,
        112,97,142,83,125,112,97,142,83,126,112,97,142,83,127,112,97,142,83,128,112,97,142,83,129,112,97,142,83,143,112,97,142,
        83,144,112,97,142,98,99,112,97,142,98,128,112,97,142,129,113,112,97,142,129,126,112,97,143,81,83,112,97,143,81,96,112,
        97,143,81,98,112,97,143,81,111,112,97,143,81,113,112,97,143,81,115,112,97,143,81,127,112,97,143,81,128,112,97,143,81,
        129,112,97,143,81,141,112,97,143,82,111,112,97,143,83,96,112,97,143,83,111,112,97,143,83,127,112,97,143,83,128,112,97,
        143,96,81,112,97,143,96,95,112,97,143,96,111,112,97,143,96,113,112,97,143,96,142,112,97,143,98,96,112,97,143,98,99,112,
        97,143,98,111,112,97,143,98,114,112,97,143,98,126,112,97,143,99,128,112,97,143,111,83,112,97,143,111,96,112,97,143,111,
        125,112,97,143,113,81,112,97,143,113,98,112,97,143,113,111,112,97,143,113,127,112,97,143,113,129,112,97,143,113,144,112,
        97,143,125,83,112,97,143,125,111,112,97,143,125,113,112,97,143,125,129,112,97,143,128,111,112,97,143,128,129,112,97,143,
        128,158,112,97,143,141,128,112,97,144,81,98,112,97,144,96,80,112,97,144,96,81,112,97,144,96,82,112,97,144,96,83,112,97,
        144,96,84,112,97,144,96,95,112,97,144,96,98,112,97,144,96,99,112,97,144,96,110,112,97,144,96,113,112,97,144,96,114,112,
        97,144,96,125,112,97,144,96,126,112,97,144,96,127,112,97,144,96,128,112,97,144,96,129,112,97,144,96,140,112,97,144,96,
        141,112,97,144,96,142,112,97,144,96,143,112,97,144,111,82,112,97,144,111,83,112,97,144,111,96,112,97,144,111,98,112,97,
        144,111,99,112,97,144,111,125,112,97,144,111,126,112,97,144,111,129,112,97,144,111,130,112,97,146,96,98,112,97,157,83,
        96,112,97,157,83,98,112,97,157,83,111,112,97,157,83,113,112,97,157,83,125,112,97,157,83,126,112,97,157,83,128,112,97,
        157,83,141,112,97,157,83,143,112,97,157,83,156,112,97,157,83,158,112,97,158,83,67,112,97,158,83,68,112,97,158,83,69,112,
        97,158,83,80,112,97,158,83,81,112,97,158,83,82,112,97,158,83,84,112,97,158,83,85,112,97,158,83,95,112,97,158,83,96,112,
        97,158,83,98,112,97,158,83,99,112,97,158,83,100,112,97,158,83,110,112,97,158,83,111,112,97,158,83,113,112,97,158,83,114,
        112,97,158,83,115,112,97,158,83,125,112,97,158,83,126,112,97,158,83,127,112,97,158,83,128,112,97,158,83,129,112,97,158,
        83,130,112,97,158,83,140,112,97,158,83,141,112,97,158,83,142,112,97,158,83,143,112,97,158,83,144,112,97,158,83,145,112,
        97,158,83,156,112,97,158,83,159,112,97,158,83,160,112,98,84,53,96,112,98,84,68,83,112,98,84,68,113,112,98,84,68,114,112,
        98,84,81,68,112,98,84,81,96,112,98,84,81,99,112,98,84,81,113,112,98,84,81,114,112,98,84,82,66,112,98,84,82,68,112,98,84,
        82,80,112,98,84,82,81,112,98,84,82,96,112,98,84,82,113,112,98,84,82,114,112,98,84,82,128,112,98,84,82,130,112,98,84,83,
        68,112,98,85,68,113,112,98,85,81,96,112,98,85,81,99,112,98,85,81,100,112,98,85,81,113,112,98,85,81,114,112,98,85,81,115,
        112,98,85,82,100,112,98,85,82,114,112,98,85,82,115,112,98,85,83,68,112,98,85,83,100,112,98,85,96,114,112,98,85,97,83,
        112,98,85,97,84,112,98,85,97,96,112,98,85,97,99,112,98,85,97,126,112,98,85,99,68,112,98,85,99,83,112,98,85,99,97,112,98,
        85,99,100,112,98,85,99,114,112,98,85,99,115,112,98,85,100,99,112,98,85,111,53,112,98,85,113,83,112,98,85,113,128,112,98,
        85,114,82,112,98,85,114,83,112,98,85,114,99,112,98,85,114,100,112,98,85,114,130,112,98,85,115,83,112,98,85,127,69,112,
        98,85,127,83,112,98,85,127,84,112,98,85,128,83,112,98,85,128,97,112,98,85,128,130,112,98,85,130,114,112,98,86,99,82,112,
        98,99,82,66,112,98,99,82,68,112,98,99,82,83,112,98,99,82,85,112,98,99,82,96,112,98,99,82,113,112,98,99,82,114,112,98,99,
        82,115,112,98,99,82,127,112,98,99,82,130,112,98,99,83,81,112,98,99,83,113,112,98,99,83,114,112,98,99,84,97,112,98,99,97,
        82,112,98,99,97,127,112,98,99,113,69,112,98,99,113,81,112,98,99,113,82,112,98,99,113,83,112,98,99,113,95,112,98,99,113,
        100,112,98,99,113,114,112,98,99,113,128,112,98,99,113,129,112,98,99,113,142,112,98,99,113,143,112,98,99,113,144,112,98,
        99,114,82,112,98,99,114,113,112,98,99,114,127,112,98,99,114,128,112,98,99,114,130,112,98,99,114,143,112,98,99,115,82,
        112,98,99,115,127,112,98,99,127,69,112,98,99,127,84,112,98,99,127,128,112,98,99,127,129,112,98,99,128,84,112,98,99,129,
        82,112,98,99,129,127,112,98,99,129,128,112,98,99,130,84,112,98,100,81,99,112,98,100,82,114,112,98,100,82,128,112,98,100,
        83,68,112,98,100,83,113,112,98,100,83,114,112,98,100,83,115,112,98,100,84,114,112,98,100,85,113,112,98,100,85,114,112,
        98,100,96,99,112,98,100,96,114,112,98,100,97,83,112,98,100,97,95,112,98,100,97,96,112,98,100,97,111,112,98,100,97,113,
        112,98,100,97,114,112,98,100,111,68,112,98,100,111,83,112,98,100,111,84,112,98,100,111,96,112,98,100,111,99,112,98,100,
        111,114,112,98,100,111,115,112,98,100,111,128,112,98,100,111,129,112,98,100,113,83,112,98,100,113,128,112,98,100,114,82,
        112,98,100,114,83,112,98,100,114,129,112,98,100,114,130,112,98,100,115,82,112,98,100,115,83,112,98,100,115,114,112,98,
        100,116,83,112,98,100,127,68,112,98,100,127,84,112,98,100,127,115,112,98,100,127,128,112,98,100,127,130,112,98,100,127,
        144,112,98,100,128,83,112,98,100,128,113,112,98,100,128,129,112,98,100,129,82,112,98,100,129,83,112,98,100,129,113,112,
        98,100,129,114,112,98,100,129,128,112,98,100,130,114,112,98,100,142,116,112,98,100,143,113,112,98,101,82,114,112,98,113,
        99,114,112,98,113,111,95,112,98,113,111,99,112,98,113,111,115,112,98,113,111,127,112,98,113,111,129,112,98,113,114,82,
        112,98,113,114,96,112,98,113,114,97,112,98,113,114,99,112,98,113,114,100,112,98,113,114,115,112,98,113,114,127,112,98,
        113,114,129,112,98,113,114,130,112,98,113,127,80,112,98,113,127,81,112,98,113,127,82,112,98,113,127,95,112,98,113,127,
        96,
    };
    static const uint8_t movpo[4735]={
        112,97,98,37,52,53,54,55,56,67,68,69,70,71,82,83,84,85,86,98,99,100,101,113,114,115,116,117,127,128,129,130,131,142,143,
        144,145,146,157,158,159,160,161,172,173,174,175,176,70,71,84,85,86,99,100,101,113,113,83,98,113,128,81,83,98,81,96,126,
        81,98,52,53,54,55,68,69,70,81,82,83,84,85,98,99,100,111,113,114,115,127,128,129,130,66,67,81,82,83,84,95,96,98,99,111,
        113,114,126,127,128,129,81,83,84,96,98,99,114,128,129,98,67,68,83,84,98,99,113,127,128,65,66,67,68,69,80,81,82,84,96,98,
        99,100,111,113,114,126,127,128,129,65,66,67,68,69,70,80,81,82,83,85,95,96,98,99,100,110,111,113,114,115,125,126,127,128,
        129,68,81,83,96,99,111,113,114,126,83,65,80,81,82,83,84,95,96,99,110,111,113,114,125,126,127,128,129,140,141,142,143,
        144,145,81,82,83,84,85,95,96,98,100,111,113,114,115,126,127,128,129,130,65,66,67,68,69,70,71,80,81,82,83,84,85,86,95,96,
        98,99,101,110,111,113,114,115,116,125,126,127,128,129,130,131,140,141,142,143,144,145,146,111,80,81,82,83,84,95,98,99,
        110,111,114,115,125,126,127,128,129,140,141,142,143,144,65,66,67,68,69,80,81,82,83,84,85,95,96,98,99,100,110,111,113,
        115,125,126,127,128,129,130,141,142,143,144,81,83,96,111,114,129,96,111,67,68,69,82,83,84,98,99,113,114,128,129,142,143,
        144,157,158,159,81,83,96,98,110,111,113,114,126,127,142,143,144,65,66,67,68,69,80,81,82,83,84,95,96,98,99,100,110,111,
        113,114,115,125,126,127,128,130,141,142,143,144,145,82,96,111,96,111,67,68,69,82,83,84,98,99,113,114,127,128,129,143,
        144,157,158,159,172,173,174,80,81,82,83,84,95,96,98,99,110,111,113,114,125,126,127,128,129,140,141,142,144,157,81,83,96,
        98,111,113,126,128,96,96,111,83,98,83,98,96,96,96,111,83,98,83,96,96,96,97,53,67,68,81,82,83,96,97,37,38,39,51,52,53,54,
        55,65,66,67,68,69,70,71,80,81,82,83,84,86,87,95,96,97,99,100,101,102,110,111,113,114,115,116,117,125,126,127,128,129,
        130,131,140,141,142,143,144,145,157,158,159,82,97,99,66,67,68,69,70,81,82,83,84,85,96,97,100,111,113,114,115,126,127,
        128,129,130,65,66,67,68,69,70,71,80,81,82,83,84,85,86,95,96,97,99,101,110,111,113,114,115,116,125,126,127,128,129,130,
        131,140,141,142,143,144,145,146,82,80,81,82,83,84,85,95,96,97,99,100,110,111,114,115,125,126,127,66,69,80,84,83,96,99,
        98,65,96,113,68,69,99,98,113,95,98,53,83,114,81,96,111,65,66,80,83,84,95,96,98,111,113,68,98,113,65,66,68,81,82,84,95,
        99,113,128,80,81,96,111,65,66,80,81,95,96,99,113,80,81,96,83,66,81,96,81,83,98,84,128,84,96,96,113,84,113,69,81,96,111,
        80,81,96,110,111,96,98,81,84,95,98,111,96,99,84,96,69,83,84,96,81,84,96,84,96,83,84,84,96,98,69,81,83,84,99,81,96,49,50,
        51,52,53,54,55,56,64,65,66,67,68,70,71,79,80,82,83,84,85,86,94,95,96,98,99,100,101,109,110,111,113,114,125,126,127,128,
        129,140,141,142,143,144,68,84,81,96,66,67,68,81,95,99,51,52,53,54,55,65,66,67,68,70,80,81,82,83,95,96,99,110,111,113,
        114,115,126,127,128,129,130,143,144,145,67,83,96,99,84,98,113,114,128,80,84,96,98,111,69,81,95,96,98,99,110,111,114,128,
        80,96,98,110,111,65,67,68,80,81,83,84,95,96,99,100,110,111,113,114,125,126,127,128,96,98,110,111,113,81,96,98,99,129,66,
        68,80,83,84,96,98,114,96,110,99,113,67,98,99,113,96,98,113,128,96,98,99,113,127,85,96,98,99,113,128,84,99,65,66,67,82,
        95,96,98,99,110,113,126,128,129,65,66,81,86,95,96,98,99,100,113,114,81,96,98,99,100,111,113,114,128,129,66,68,81,82,84,
        95,98,99,110,111,113,114,126,127,128,66,80,81,82,84,95,96,99,100,110,111,113,114,115,125,126,127,128,129,66,80,81,84,85,
        96,98,100,111,113,128,129,80,81,96,98,99,113,128,129,66,67,68,81,82,84,96,98,99,113,114,115,127,128,129,143,66,80,81,82,
        84,96,98,99,110,111,114,126,127,128,129,80,81,84,96,98,99,100,110,113,128,66,67,68,81,82,84,98,99,113,114,115,81,82,84,
        96,98,99,113,114,128,68,80,81,84,99,68,80,81,84,96,98,100,111,113,126,128,98,113,98,113,98,114,96,98,96,98,98,128,98,
        114,99,100,98,113,68,82,96,98,111,114,128,98,128,68,98,98,99,113,114,66,67,68,69,70,80,81,82,83,85,95,96,99,100,111,113,
        114,115,127,128,129,130,83,96,98,113,128,98,128,98,114,83,96,98,99,113,81,82,83,98,128,68,83,96,98,128,96,98,83,98,68,
        69,70,81,83,85,96,98,99,100,111,68,83,98,98,113,96,98,98,113,84,99,68,69,70,96,98,99,100,111,115,81,95,98,99,98,100,99,
        65,66,67,68,69,70,80,81,82,83,84,95,96,98,99,100,110,111,114,115,125,126,127,128,129,130,140,141,142,143,144,145,83,98,
        99,83,100,115,113,126,113,126,82,83,84,96,99,111,113,114,115,126,127,128,129,142,143,84,126,84,126,69,81,96,110,111,114,
        126,128,84,113,114,66,80,81,82,83,84,99,100,111,113,114,115,126,127,128,129,141,142,143,144,84,126,84,114,128,68,69,80,
        82,83,84,96,113,114,126,128,68,84,85,99,100,111,114,115,116,126,127,128,129,140,141,142,143,144,145,146,157,158,160,84,
        126,83,84,114,68,70,81,82,83,84,96,99,111,113,114,115,128,129,144,66,68,82,83,84,96,111,113,114,126,128,130,67,68,81,82,
        83,84,96,111,113,114,125,126,127,129,140,81,82,84,99,111,113,114,126,128,84,113,114,84,113,114,84,113,114,126,84,114,84,
        113,84,113,98,111,113,114,115,129,113,114,68,69,84,111,113,114,128,111,113,128,111,128,83,114,80,81,82,83,84,111,113,
        114,126,127,129,82,83,113,114,127,128,129,113,128,67,68,69,80,81,82,83,84,96,98,113,114,115,125,126,127,128,129,144,81,
        83,84,98,129,81,83,95,96,98,113,126,127,128,143,113,128,67,81,83,84,111,113,114,115,128,129,83,84,113,83,84,113,126,83,
        98,113,84,113,84,113,114,128,114,128,111,113,114,115,128,130,144,68,81,82,84,95,98,49,50,51,52,53,54,64,65,66,67,68,69,
        70,79,80,81,82,83,84,85,94,95,96,99,109,110,111,113,114,115,126,127,128,129,130,131,142,143,144,145,146,159,160,161,68,
        83,84,96,84,128,129,83,84,98,99,129,130,68,84,84,85,116,85,98,111,96,98,99,111,127,128,141,143,98,111,96,111,125,126,
        127,141,111,128,98,111,82,84,95,96,110,111,114,126,127,128,141,142,98,111,128,98,127,81,83,84,95,96,98,99,110,125,126,
        127,128,129,141,142,143,144,157,83,96,98,99,111,126,128,129,98,128,111,114,114,127,83,98,99,111,114,126,84,95,96,98,99,
        111,114,125,126,127,140,141,142,98,111,114,98,114,98,111,98,114,99,111,114,98,126,113,128,98,113,98,113,98,128,98,113,
        128,98,128,98,99,128,129,83,84,98,99,111,113,128,129,82,84,98,99,100,111,113,128,142,128,144,98,128,144,98,99,128,81,82,
        83,98,99,113,126,127,128,129,144,82,83,84,99,113,128,142,144,98,128,98,128,98,113,83,84,96,98,99,113,115,125,126,127,
        128,129,142,143,144,81,83,98,128,129,142,143,144,98,128,113,128,82,98,113,115,128,82,113,128,144,83,84,98,113,129,143,
        81,83,96,98,111,113,126,113,128,98,128,98,113,127,98,113,98,113,98,99,113,114,129,143,69,100,111,129,70,80,81,82,83,84,
        85,95,96,98,99,100,110,113,114,125,126,127,128,129,130,140,141,142,143,144,145,130,144,145,95,81,83,95,96,126,125,128,
        129,83,126,128,111,128,99,113,128,69,81,82,95,96,98,99,110,111,113,114,125,126,128,129,141,142,143,128,129,69,81,82,83,
        84,85,95,96,99,100,109,110,111,113,114,125,126,128,129,140,141,142,143,157,96,111,81,82,95,98,110,111,125,126,128,129,
        140,141,143,144,95,96,98,111,129,142,143,99,111,113,143,111,113,126,82,83,98,99,113,114,128,129,143,158,81,82,83,96,98,
        111,113,114,126,128,129,141,144,157,158,98,126,113,128,113,126,98,126,83,96,98,129,143,144,96,98,111,114,125,129,143,65,
        66,67,79,80,81,82,83,84,94,95,98,99,110,111,113,114,115,125,126,127,129,130,140,141,142,143,144,145,157,158,159,160,95,
        96,110,113,114,126,144,95,114,83,95,96,98,99,113,114,125,126,129,144,95,96,98,114,126,127,129,142,144,145,96,144,96,111,
        96,144,130,144,96,114,96,113,114,128,144,128,144,128,144,98,128,111,128,114,144,96,114,127,128,143,144,157,111,115,128,
        143,69,96,99,111,114,115,126,127,128,142,128,144,98,114,84,95,98,99,111,114,125,126,128,143,82,83,84,96,99,111,113,115,
        126,127,128,143,98,111,128,98,128,114,115,81,83,84,95,96,98,99,113,114,115,125,126,127,128,142,143,144,157,83,95,98,99,
        100,111,114,115,125,126,127,128,130,141,142,143,144,157,98,115,126,128,143,128,144,98,114,96,111,114,143,157,143,144,
        114,143,98,143,144,128,143,144,128,144,98,144,111,143,98,126,81,82,95,98,111,128,143,96,98,110,126,128,128,141,114,128,
        143,65,66,67,68,69,80,81,82,84,94,95,96,98,99,100,110,111,113,114,125,126,127,128,129,140,141,143,144,141,143,80,81,95,
        96,99,100,110,111,114,125,126,127,128,140,141,143,144,156,157,158,172,96,126,128,128,129,126,143,128,158,126,143,113,
        126,128,126,128,126,141,128,144,128,144,126,128,128,144,126,128,126,128,128,144,83,96,98,111,113,114,115,126,127,128,
        129,141,142,157,111,115,129,96,111,127,128,141,142,142,144,98,128,81,95,98,111,113,115,127,128,129,141,142,144,157,81,
        96,99,111,114,126,127,129,141,142,144,96,128,144,98,129,83,96,125,81,96,98,99,111,114,126,127,128,129,140,141,142,144,
        127,129,142,83,96,98,111,113,128,129,111,127,128,129,144,113,128,141,144,111,127,129,142,158,144,145,159,128,144,98,111,
        126,128,128,129,126,129,128,144,98,128,129,142,111,143,80,81,82,83,84,95,98,99,110,111,113,114,125,126,127,128,129,140,
        141,142,143,99,143,80,81,82,83,84,96,98,99,113,114,115,125,126,128,129,130,143,158,98,128,143,111,143,98,129,143,98,96,
        98,111,113,125,126,128,141,143,156,158,67,68,69,80,81,82,84,85,95,96,98,99,100,110,111,113,114,115,125,126,127,128,129,
        130,140,141,142,143,144,145,156,157,159,160,96,99,96,114,68,99,113,114,83,113,114,68,96,99,113,114,66,68,80,81,96,97,
        113,114,128,129,130,68,99,113,68,83,97,99,114,127,83,114,113,114,99,113,114,65,66,67,68,69,70,80,82,83,84,95,96,97,99,
        100,110,111,113,114,115,125,126,127,128,129,130,66,67,68,69,70,71,81,83,84,86,96,97,99,100,101,111,113,114,115,116,126,
        127,128,129,130,131,52,53,54,66,67,68,69,70,71,80,81,82,84,86,95,96,97,99,100,101,110,111,113,114,115,116,126,127,128,
        130,131,142,143,144,99,115,114,115,52,53,54,65,66,67,68,69,70,71,80,81,82,83,84,86,95,96,99,101,110,111,113,114,115,116,
        125,126,127,128,129,130,131,52,53,54,66,67,68,70,71,80,81,82,83,84,86,95,96,97,100,101,110,111,113,114,115,116,126,127,
        128,129,130,131,143,144,145,99,82,128,53,99,115,83,128,52,53,54,66,67,68,70,71,81,82,83,84,86,96,97,99,100,101,111,113,
        115,116,126,127,128,129,130,131,141,142,143,144,145,146,82,83,69,83,84,83,97,130,114,69,83,82,83,113,114,113,114,127,
        128,113,114,128,113,128,113,128,113,128,66,68,81,83,85,96,113,114,115,127,128,130,68,81,82,97,113,114,127,128,129,82,83,
        97,113,114,127,128,82,97,113,114,128,83,113,115,127,128,130,142,144,81,82,83,84,113,114,126,127,129,141,142,143,113,114,
        127,83,100,113,114,69,70,81,82,83,84,95,96,97,100,111,114,116,126,127,128,129,130,140,141,142,143,144,81,82,83,85,100,
        113,127,128,130,143,82,127,128,83,115,69,83,84,114,128,129,130,143,81,82,83,84,113,114,115,127,130,82,83,113,115,127,
        128,143,82,83,84,97,113,114,127,128,129,99,114,114,115,128,68,113,114,115,128,113,114,128,113,114,128,97,99,114,83,95,
        96,99,111,113,114,128,68,83,84,85,96,97,99,114,115,128,129,83,128,82,83,129,130,82,83,114,83,68,84,113,115,128,130,144,
        83,113,129,143,82,83,113,114,128,82,114,83,85,116,83,113,114,97,127,99,114,127,96,97,99,114,127,128,129,130,96,97,111,
        114,127,97,114,127,97,111,97,114,127,97,99,114,126,127,128,95,96,111,82,83,96,97,100,114,129,97,114,95,97,111,127,82,95,
        96,99,115,127,129,82,84,96,97,99,100,115,127,128,129,130,143,82,97,111,97,114,127,129,96,97,111,114,80,81,82,95,96,98,
        98,99,96,69,98,99,129,128,83,84,65,111,113,126,81,96,111,80,80,95,96,110,113,66,96,126,65,80,84,113,111,66,69,81,83,84,
        50,51,52,53,54,65,66,68,69,80,81,83,84,95,96,99,110,111,113,114,125,126,127,128,129,50,51,52,53,54,65,66,68,69,80,81,83,
        84,95,96,98,99,110,111,114,128,69,111,98,111,111,98,95,80,81,110,95,80,83,96,111,95,96,80,66,68,81,84,95,99,68,98,95,98,
        80,81,95,98,99,98,111,67,80,96,80,95,96,110,111,80,82,96,111,110,80,83,84,113,53,67,80,83,94,95,98,99,81,111,81,98,126,
        84,80,51,52,53,54,55,66,67,69,70,81,82,83,84,85,95,96,100,111,113,114,115,126,127,128,129,130,98,66,96,80,81,113,111,
        113,111,113,113,80,81,95,95,80,114,113,100,66,113,128,113,98,66,81,83,84,99,113,114,98,66,68,81,96,111,96,69,98,80,98,
        111,66,69,84,114,98,99,98,110,111,99,111,114,96,114,96,110,98,96,96,80,110,96,111,110,83,96,96,96,96,113,83,83,68,81,
        110,128,81,83,96,111,113,126,113,83,96,96,99,110,113,96,96,114,68,128,83,84,113,80,81,128,98,84,113,68,113,113,113,128,
        96,96,66,67,95,96,113,113,80,99,128,67,115,128,81,96,99,110,113,114,126,99,128,96,128,98,113,81,98,113,81,95,98,81,95,
        82,66,81,111,113,82,128,99,114,129,96,100,84,113,129,98,82,81,80,81,84,126,129,84,99,81,99,81,99,129,81,96,99,96,98,80,
        81,84,98,96,113,99,81,99,113,128,99,98,114,99,99,126,126,125,111,126,83,113,81,96,100,113,99,113,96,83,66,83,96,113,81,
        82,85,96,114,113,114,68,80,81,82,83,99,111,113,114,128,69,96,114,68,95,96,113,114,113,69,96,99,111,114,127,129,83,96,99,
        111,113,128,129,113,83,96,83,96,113,96,98,70,96,96,96,96,111,81,69,83,84,70,86,114,115,83,96,98,114,115,128,130,83,96,
        113,96,111,81,126,128,84,140,99,126,85,113,110,99,113,70,126,84,140,84,140,84,129,84,126,129,69,84,129,84,140,81,84,96,
        129,84,99,114,115,127,128,130,144,126,84,129,84,126,129,84,126,129,84,96,99,111,114,126,127,129,81,111,126,83,81,96,111,
        126,127,81,111,113,68,82,83,68,113,128,70,81,82,83,85,96,100,111,113,114,127,129,114,96,111,83,111,83,83,96,111,113,113,
        111,84,84,83,84,126,84,84,70,126,114,113,126,128,84,140,83,143,70,126,111,70,83,70,113,113,113,111,111,113,84,84,69,114,
        113,84,111,111,83,126,110,113,114,111,114,81,83,95,96,96,126,96,95,81,84,115,127,126,80,128,83,96,83,84,96,126,127,129,
        126,127,125,125,96,126,83,81,114,130,144,67,82,96,111,128,67,81,128,96,127,128,83,98,110,111,113,125,127,140,141,142,
        113,96,98,113,126,127,129,130,144,114,128,83,113,126,114,127,111,96,83,111,114,128,128,85,114,83,83,81,95,110,111,68,98,
        111,110,126,83,81,96,68,114,128,113,114,115,128,111,128,113,96,111,114,84,96,81,96,80,83,98,68,70,116,115,116,116,84,98,
        69,111,110,111,114,111,111,110,111,114,83,111,98,125,98,114,125,126,83,83,96,127,96,126,128,96,96,83,98,99,128,111,128,
        128,83,110,126,128,143,111,111,98,82,99,84,96,98,128,113,111,96,100,111,96,81,126,111,98,113,111,96,111,81,84,96,98,113,
        126,129,96,98,126,80,128,83,84,126,81,96,126,129,95,125,96,142,81,83,95,96,126,96,96,96,144,128,128,83,111,115,96,111,
        144,129,84,98,99,115,113,128,113,83,96,111,113,111,96,98,113,69,113,81,95,81,99,83,83,83,95,96,95,98,96,129,113,128,160,
        81,95,81,83,83,98,113,83,85,113,99,111,96,126,98,99,98,99,110,111,113,143,80,111,111,98,95,113,99,111,98,98,98,96,96,95,
        98,99,113,114,111,113,126,128,113,128,113,96,99,114,96,126,129,114,81,111,144,98,113,128,126,98,143,98,128,111,113,111,
        143,98,113,126,128,141,143,111,113,126,126,141,99,111,114,126,128,111,113,126,126,111,114,126,128,158,111,126,113,128,
        128,113,141,113,129,129,142,157,111,111,111,83,98,110,111,98,81,98,111,81,98,110,111,113,114,125,126,127,142,143,113,
        126,81,111,95,98,110,113,126,127,98,81,111,94,110,98,81,111,81,111,111,111,81,111,111,111,127,96,144,111,111,96,111,111,
        83,98,98,113,128,98,98,96,111,110,126,81,81,98,81,114,83,100,114,144,83,83,128,113,128,111,95,95,98,114,125,141,143,96,
        98,125,80,83,128,83,126,83,126,96,83,83,95,96,98,126,128,143,125,83,95,96,142,81,126,98,98,130,128,96,99,111,143,98,115,
        157,98,114,111,96,99,111,128,111,68,98,81,98,111,126,98,99,98,81,99,98,99,111,99,98,98,113,99,80,81,111,128,84,81,111,
        98,113,111,100,99,98,98,96,98,99,99,81,96,98,96,98,114,114,96,114,98,113,113,83,113,83,84,111,126,110,113,111,114,111,
        96,96,111,96,113,80,113,95,98,96,125,99,111,125,126,127,129,95,98,113,111,81,128,83,113,114,96,113,83,83,113,81,96,113,
        126,129,125,128,83,95,126,96,126,81,98,99,96,94,98,109,111,113,128,141,157,95,110,113,111,96,127,99,111,115,157,159,98,
        157,96,111,83,84,111,68,111,95,95,95,111,126,81,98,111,111,126,81,98,81,81,111,98,95,81,111,111,113,127,126,128,125,83,
        96,98,83,96,125,126,80,81,98,99,113,128,84,111,113,111,81,96,98,99,111,113,98,96,98,99,98,98,99,81,111,98,99,111,99,98,
        81,99,80,84,113,81,98,113,111,113,81,99,98,99,96,111,111,98,98,96,113,96,99,113,99,99,128,82,114,113,100,82,128,114,114,
        96,99,111,113,115,127,129,53,68,96,100,101,113,114,128,130,143,114,114,114,114,114,99,113,128,114,96,100,114,67,80,128,
        113,96,111,114,96,113,115,128,115,114,99,115,113,114,129,83,128,113,113,114,114,67,68,69,70,82,83,84,100,113,114,115,
        127,128,129,130,67,68,69,70,82,83,84,97,113,114,115,127,128,129,130,83,115,100,113,127,82,97,96,129,67,81,83,97,82,68,
        100,113,128,68,70,82,99,115,68,100,115,82,111,82,83,82,129,129,100,115,83,113,81,114,114,113,114,114,113,129,83,83,83,
        96,114,127,114,129,113,83,143,113,114,82,128,68,81,83,96,97,128,67,82,97,82,128,129,128,84,97,128,129,96,97,114,126,127,
        129,144,83,84,114,115,128,143,130,82,97,129,128,67,83,97,127,130,97,113,142,127,130,144,115,128,143,82,97,113,114,128,
        128,129,114,144,115,130,113,143,113,82,113,128,114,128,115,84,114,128,128,128,114,128,114,115,113,128,114,83,113,128,
        128,113,111,128,84,96,68,128,83,115,127,128,96,96,96,82,97,129,114,83,96,97,82,83,130,143,145,83,82,128,97,84,111,128,
        68,95,111,116,85,130,114,130,113,116,143,128,82,129,83,114,111,115,97,127,128,82,115,114,128,114,128,113,114,96,111,81,
        114,114,97,114,129,142,97,81,97,127,128,99,126,129,82,130,82,130,129,99,97,130,100,127,128,129,96,111,114,97,110,111,
        114,129,80,81,95,96,110,111,114,81,110,111,114,128,
    };
    static const entry entri[1392]={
        {0,0,0,1},{0,1,1,2},{1,2,3,45},{3,2,48,9},{5,3,57,1},{8,3,58,4},{11,3,62,3},
        {14,3,65,3},{17,3,68,1},{20,3,69,1},{23,3,70,23},{26,3,93,17},{29,3,110,9},{32,3,119,1},
        {35,3,120,9},{38,3,129,20},{41,3,149,26},{44,3,175,9},{47,3,184,1},{50,3,185,24},{53,3,209,18},
        {56,3,227,39},{59,3,266,1},{62,3,267,22},{65,3,289,30},{68,3,319,6},{71,3,325,2},{74,3,327,18},
        {77,3,345,13},{80,3,358,30},{83,3,388,3},{86,3,391,2},{89,3,393,21},{92,3,414,23},{95,3,437,8},
        {98,3,445,1},{101,3,446,2},{104,3,448,2},{107,3,450,2},{110,3,452,1},{113,3,453,1},{116,3,454,2},
        {119,3,456,2},{122,3,458,1},{125,3,459,1},{128,3,460,1},{131,3,461,1},{134,3,462,1},{137,3,463,8},
        {140,3,471,52},{143,3,523,3},{146,3,526,22},{149,3,548,39},{152,3,587,1},{155,3,588,18},{158,4,606,4},
        {162,4,610,3},{166,4,613,1},{170,4,614,3},{174,4,617,2},{178,4,619,1},{182,4,620,2},{186,4,622,2},
        {190,4,624,3},{194,4,627,3},{198,4,630,10},{202,4,640,3},{206,4,643,10},{210,4,653,4},{214,4,657,8},
        {218,4,665,3},{222,4,668,1},{226,4,669,3},{230,4,672,3},{234,4,675,2},{238,4,677,2},{242,4,679,2},
        {246,4,681,2},{250,4,683,4},{254,4,687,5},{258,4,692,2},{262,4,694,5},{266,4,699,2},{270,4,701,2},
        {274,4,703,4},{278,4,707,3},{282,4,710,2},{286,4,712,2},{290,4,714,3},{294,4,717,5},{298,4,722,2},
        {302,4,724,44},{306,4,768,2},{310,4,770,2},{314,4,772,6},{318,4,778,30},{322,4,808,1},{326,4,809,3},
        {330,4,812,5},{334,4,817,5},{338,4,822,10},{342,4,832,5},{346,4,837,19},{350,4,856,5},{354,4,861,5},
        {358,4,866,8},{362,4,874,2},{366,4,876,2},{370,4,878,4},{374,4,882,4},{378,4,886,5},{382,4,891,6},
        {386,4,897,2},{390,4,899,13},{394,4,912,11},{398,4,923,10},{402,4,933,15},{406,4,948,19},{410,4,967,12},
        {414,4,979,8},{418,4,987,16},{422,4,1003,15},{426,4,1018,10},{430,4,1028,11},{434,4,1039,9},{438,4,1048,5},
        {442,4,1053,11},{446,4,1064,2},{450,4,1066,2},{454,4,1068,2},{458,4,1070,2},{462,4,1072,2},{466,4,1074,2},
        {470,4,1076,2},{474,4,1078,2},{478,4,1080,2},{482,4,1082,7},{486,4,1089,2},{490,4,1091,2},{494,4,1093,4},
        {498,4,1097,22},{502,4,1119,5},{506,4,1124,2},{510,4,1126,2},{514,4,1128,5},{518,4,1133,5},{522,4,1138,5},
        {526,4,1143,2},{530,4,1145,2},{534,4,1147,11},{538,4,1158,3},{542,4,1161,2},{546,4,1163,2},{550,4,1165,2},
        {554,4,1167,2},{558,4,1169,9},{562,4,1178,4},{566,4,1182,2},{570,4,1184,1},{574,4,1185,32},{578,4,1217,3},
        {582,4,1220,3},{586,4,1223,2},{590,4,1225,2},{594,4,1227,15},{598,4,1242,2},{602,4,1244,2},{606,4,1246,8},
        {610,4,1254,3},{614,4,1257,20},{618,4,1277,2},{622,4,1279,3},{626,4,1282,11},{630,4,1293,23},{634,4,1316,2},
        {638,4,1318,3},{642,4,1321,15},{646,4,1336,12},{650,4,1348,15},{654,4,1363,9},{658,4,1372,3},{662,4,1375,3},
        {666,4,1378,4},{670,4,1382,2},{674,4,1384,2},{678,4,1386,2},{682,4,1388,6},{686,4,1394,2},{690,4,1396,7},
        {694,4,1403,3},{698,4,1406,2},{702,4,1408,2},{706,4,1410,11},{710,4,1421,7},{714,4,1428,2},{718,4,1430,19},
        {722,4,1449,5},{726,4,1454,10},{730,4,1464,2},{734,4,1466,10},{738,4,1476,3},{742,4,1479,4},{746,4,1483,3},
        {750,4,1486,2},{754,4,1488,4},{758,4,1492,2},{762,4,1494,7},{766,4,1501,6},{770,4,1507,44},{774,4,1551,4},
        {778,4,1555,3},{782,4,1558,6},{786,4,1564,2},{790,4,1566,3},{794,4,1569,1},{798,4,1570,2},{802,4,1572,8},
        {806,4,1580,2},{810,4,1582,6},{814,4,1588,2},{818,4,1590,2},{822,4,1592,12},{826,4,1604,3},{830,4,1607,2},
        {834,4,1609,18},{838,4,1627,8},{842,4,1635,2},{846,4,1637,2},{850,4,1639,2},{854,4,1641,6},{858,4,1647,13},
        {862,4,1660,3},{866,4,1663,2},{870,4,1665,2},{874,4,1667,2},{878,4,1669,3},{882,4,1672,2},{886,4,1674,2},
        {890,4,1676,2},{894,4,1678,2},{898,4,1680,2},{902,4,1682,3},{906,4,1685,2},{910,4,1687,4},{914,4,1691,8},
        {918,4,1699,9},{922,4,1708,2},{926,4,1710,3},{930,4,1713,3},{934,4,1716,11},{938,4,1727,8},{942,4,1735,2},
        {946,4,1737,2},{950,4,1739,2},{954,4,1741,15},{958,4,1756,8},{962,4,1764,2},{966,4,1766,2},{970,4,1768,5},
        {974,4,1773,4},{978,4,1777,6},{982,4,1783,7},{986,4,1790,2},{990,4,1792,2},{994,4,1794,3},{998,4,1797,2},
        {1002,4,1799,2},{1006,4,1801,6},{1010,4,1807,4},{1014,4,1811,27},{1018,4,1838,1},{1022,4,1839,2},{1026,4,1841,1},
        {1030,4,1842,5},{1034,4,1847,3},{1038,4,1850,3},{1042,4,1853,2},{1046,4,1855,3},{1050,4,1858,18},{1054,4,1876,2},
        {1058,4,1878,24},{1062,4,1902,2},{1066,4,1904,14},{1070,4,1918,7},{1074,4,1925,4},{1078,4,1929,3},{1082,4,1932,10},
        {1086,4,1942,15},{1090,4,1957,2},{1094,4,1959,2},{1098,4,1961,2},{1102,4,1963,2},{1106,4,1965,6},{1110,4,1971,7},
        {1114,4,1978,33},{1118,4,2011,7},{1122,4,2018,2},{1126,4,2020,11},{1130,4,2031,10},{1134,4,2041,2},{1138,4,2043,2},
        {1142,4,2045,2},{1146,4,2047,2},{1150,4,2049,2},{1154,4,2051,3},{1158,4,2054,2},{1162,4,2056,2},{1166,4,2058,2},
        {1170,4,2060,2},{1174,4,2062,2},{1178,4,2064,2},{1182,4,2066,7},{1186,4,2073,4},{1190,4,2077,10},{1194,4,2087,2},
        {1198,4,2089,2},{1202,4,2091,10},{1206,4,2101,12},{1210,4,2113,3},{1214,4,2116,2},{1218,4,2118,2},{1222,4,2120,18},
        {1226,4,2138,18},{1230,4,2156,5},{1234,4,2161,2},{1238,4,2163,2},{1242,4,2165,5},{1246,4,2170,2},{1250,4,2172,2},
        {1254,4,2174,3},{1258,4,2177,3},{1262,4,2180,2},{1266,4,2182,2},{1270,4,2184,2},{1274,4,2186,2},{1278,4,2188,5},
        {1282,4,2193,2},{1286,4,2195,5},{1290,4,2200,2},{1294,4,2202,3},{1298,4,2205,28},{1302,4,2233,2},{1306,4,2235,21},
        {1310,4,2256,3},{1314,4,2259,2},{1318,4,2261,2},{1322,4,2263,2},{1326,4,2265,2},{1330,4,2267,3},{1334,4,2270,2},
        {1338,4,2272,2},{1342,4,2274,2},{1346,4,2276,2},{1350,4,2278,2},{1354,4,2280,2},{1358,4,2282,2},{1362,4,2284,2},
        {1366,4,2286,2},{1370,4,2288,14},{1374,4,2302,3},{1378,4,2305,6},{1382,4,2311,2},{1386,4,2313,2},{1390,4,2315,13},
        {1394,4,2328,11},{1398,4,2339,3},{1402,4,2342,2},{1406,4,2344,3},{1410,4,2347,14},{1414,4,2361,3},{1418,4,2364,7},
        {1422,4,2371,5},{1426,4,2376,4},{1430,4,2380,5},{1434,4,2385,3},{1438,4,2388,2},{1442,4,2390,4},{1446,4,2394,2},
        {1450,4,2396,2},{1454,4,2398,2},{1458,4,2400,4},{1462,4,2404,2},{1466,4,2406,21},{1470,4,2427,2},{1474,4,2429,18},
        {1478,4,2447,3},{1482,4,2450,2},{1486,4,2452,3},{1490,4,2455,1},{1494,4,2456,11},{1498,4,2467,34},{1502,4,2501,2},
        {1506,4,2503,2},{1510,4,2505,4},{1514,4,2509,3},{1518,4,2512,5},{1522,4,2517,11},{1526,4,2528,3},{1530,4,2531,6},
        {1534,4,2537,2},{1538,4,2539,2},{1542,4,2541,2},{1546,4,2543,1},{1550,4,2544,26},{1554,4,2570,26},{1558,4,2596,34},
        {1562,4,2630,2},{1566,4,2632,2},{1570,4,2634,33},{1574,4,2667,34},{1578,4,2701,1},{1582,4,2702,2},{1586,4,2704,3},
        {1590,4,2707,2},{1594,4,2709,34},{1598,4,2743,2},{1602,4,2745,3},{1606,4,2748,3},{1610,4,2751,1},{1614,4,2752,2},
        {1618,4,2754,1},{1622,4,2755,3},{1626,4,2758,4},{1630,4,2762,3},{1634,4,2765,2},{1638,4,2767,2},{1642,4,2769,2},
        {1646,4,2771,12},{1650,4,2783,9},{1654,4,2792,7},{1658,4,2799,5},{1662,4,2804,8},{1666,4,2812,12},{1670,4,2824,3},
        {1674,4,2827,4},{1678,4,2831,23},{1682,4,2854,10},{1686,4,2864,3},{1690,4,2867,2},{1694,4,2869,8},{1698,4,2877,9},
        {1702,4,2886,7},{1706,4,2893,9},{1710,4,2902,2},{1714,4,2904,3},{1718,4,2907,5},{1722,4,2912,3},{1726,4,2915,3},
        {1730,4,2918,3},{1734,4,2921,8},{1738,4,2929,11},{1742,4,2940,2},{1746,4,2942,4},{1750,4,2946,3},{1754,4,2949,1},
        {1758,4,2950,7},{1762,4,2957,4},{1766,4,2961,5},{1770,4,2966,2},{1774,4,2968,3},{1778,4,2971,2},{1782,4,2973,1},
        {1786,4,2974,2},{1790,4,2976,3},{1794,4,2979,8},{1798,4,2987,5},{1802,4,2992,3},{1806,4,2995,2},{1810,4,2997,3},
        {1814,4,3000,6},{1818,4,3006,3},{1822,4,3009,7},{1826,4,3016,2},{1830,4,3018,4},{1834,4,3022,7},{1838,4,3029,12},
        {1842,4,3041,3},{1846,4,3044,4},{1850,4,3048,4},{1854,4,3052,5},{1858,5,3057,1},{1863,5,3058,2},{1868,5,3060,1},
        {1873,5,3061,2},{1878,5,3063,2},{1883,5,3065,1},{1888,5,3066,1},{1893,5,3067,1},{1898,5,3068,1},{1903,5,3069,1},
        {1908,5,3070,1},{1913,5,3071,1},{1918,5,3072,1},{1923,5,3073,1},{1928,5,3074,1},{1933,5,3075,1},{1938,5,3076,5},
        {1943,5,3081,1},{1948,5,3082,1},{1953,5,3083,1},{1958,5,3084,1},{1963,5,3085,1},{1968,5,3086,1},{1973,5,3087,1},
        {1978,5,3088,1},{1983,5,3089,5},{1988,5,3094,25},{1993,5,3119,21},{1998,5,3140,1},{2003,5,3141,1},{2008,5,3142,2},
        {2013,5,3144,1},{2018,5,3145,1},{2023,5,3146,1},{2028,5,3147,1},{2033,5,3148,2},{2038,5,3150,1},{2043,5,3151,1},
        {2048,5,3152,1},{2053,5,3153,2},{2058,5,3155,2},{2063,5,3157,1},{2068,5,3158,6},{2073,5,3164,2},{2078,5,3166,2},
        {2083,5,3168,2},{2088,5,3170,2},{2093,5,3172,1},{2098,5,3173,2},{2103,5,3175,1},{2108,5,3176,1},{2113,5,3177,1},
        {2118,5,3178,5},{2123,5,3183,1},{2128,5,3184,3},{2133,5,3187,1},{2138,5,3188,1},{2143,5,3189,3},{2148,5,3192,8},
        {2153,5,3200,2},{2158,5,3202,3},{2163,5,3205,1},{2168,5,3206,1},{2173,5,3207,26},{2178,5,3233,1},{2183,5,3234,2},
        {2188,5,3236,2},{2193,5,3238,1},{2198,5,3239,2},{2203,5,3241,1},{2208,5,3242,1},{2213,5,3243,1},{2218,5,3244,1},
        {2223,5,3245,1},{2228,5,3246,1},{2233,5,3247,1},{2238,5,3248,1},{2243,5,3249,1},{2248,5,3250,1},{2253,5,3251,1},
        {2258,5,3252,2},{2263,5,3254,1},{2268,5,3255,1},{2273,5,3256,1},{2278,5,3257,7},{2283,5,3264,1},{2288,5,3265,5},
        {2293,5,3270,1},{2298,5,3271,2},{2303,5,3273,3},{2308,5,3276,4},{2313,5,3280,1},{2318,5,3281,1},{2323,5,3282,3},
        {2328,5,3285,3},{2333,5,3288,2},{2338,5,3290,2},{2343,5,3292,1},{2348,5,3293,1},{2353,5,3294,1},{2358,5,3295,2},
        {2363,5,3297,2},{2368,5,3299,1},{2373,5,3300,2},{2378,5,3302,1},{2383,5,3303,1},{2388,5,3304,2},{2393,5,3306,1},
        {2398,5,3307,1},{2403,5,3308,4},{2408,5,3312,6},{2413,5,3318,1},{2418,5,3319,2},{2423,5,3321,3},{2428,5,3324,1},
        {2433,5,3325,1},{2438,5,3326,2},{2443,5,3328,2},{2448,5,3330,2},{2453,5,3332,1},{2458,5,3333,2},{2463,5,3335,1},
        {2468,5,3336,1},{2473,5,3337,2},{2478,5,3339,1},{2483,5,3340,1},{2488,5,3341,1},{2493,5,3342,2},{2498,5,3344,1},
        {2503,5,3345,1},{2508,5,3346,5},{2513,5,3351,1},{2518,5,3352,3},{2523,5,3355,2},{2528,5,3357,1},{2533,5,3358,7},
        {2538,5,3365,2},{2543,5,3367,1},{2548,5,3368,1},{2553,5,3369,2},{2558,5,3371,3},{2563,5,3374,1},{2568,5,3375,1},
        {2573,5,3376,1},{2578,5,3377,2},{2583,5,3379,1},{2588,5,3380,4},{2593,5,3384,2},{2598,5,3386,1},{2603,5,3387,1},
        {2608,5,3388,1},{2613,5,3389,1},{2618,5,3390,1},{2623,5,3391,2},{2628,5,3393,1},{2633,5,3394,1},{2638,5,3395,1},
        {2643,5,3396,1},{2648,5,3397,1},{2653,5,3398,4},{2658,5,3402,1},{2663,5,3403,1},{2668,5,3404,1},{2673,5,3405,1},
        {2678,5,3406,3},{2683,5,3409,2},{2688,5,3411,1},{2693,5,3412,1},{2698,5,3413,1},{2703,5,3414,2},{2708,5,3416,1},
        {2713,5,3417,1},{2718,5,3418,1},{2723,5,3419,1},{2728,5,3420,1},{2733,5,3421,1},{2738,5,3422,2},{2743,5,3424,1},
        {2748,5,3425,1},{2753,5,3426,2},{2758,5,3428,1},{2763,5,3429,1},{2768,5,3430,1},{2773,5,3431,1},{2778,5,3432,1},
        {2783,5,3433,1},{2788,5,3434,1},{2793,5,3435,1},{2798,5,3436,1},{2803,5,3437,4},{2808,5,3441,1},{2813,5,3442,1},
        {2818,5,3443,1},{2823,5,3444,1},{2828,5,3445,4},{2833,5,3449,5},{2838,5,3454,2},{2843,5,3456,10},{2848,5,3466,3},
        {2853,5,3469,5},{2858,5,3474,1},{2863,5,3475,7},{2868,5,3482,7},{2873,5,3489,1},{2878,5,3490,1},{2883,5,3491,1},
        {2888,5,3492,2},{2893,5,3494,1},{2898,5,3495,1},{2903,5,3496,1},{2908,5,3497,1},{2913,5,3498,1},{2918,5,3499,1},
        {2923,5,3500,1},{2928,5,3501,2},{2933,5,3503,1},{2938,5,3504,1},{2943,5,3505,2},{2948,5,3507,4},{2953,5,3511,7},
        {2958,5,3518,3},{2963,5,3521,1},{2968,5,3522,1},{2973,5,3523,1},{2978,5,3524,2},{2983,5,3526,2},{2988,5,3528,2},
        {2993,5,3530,1},{2998,5,3531,1},{3003,5,3532,1},{3008,5,3533,2},{3013,5,3535,2},{3018,5,3537,2},{3023,5,3539,1},
        {3028,5,3540,1},{3033,5,3541,1},{3038,5,3542,1},{3043,5,3543,2},{3048,5,3545,1},{3053,5,3546,2},{3058,5,3548,1},
        {3063,5,3549,2},{3068,5,3551,1},{3073,5,3552,3},{3078,5,3555,8},{3083,5,3563,1},{3088,5,3564,2},{3093,5,3566,3},
        {3098,5,3569,3},{3103,5,3572,8},{3108,5,3580,3},{3113,5,3583,1},{3118,5,3584,5},{3123,5,3589,3},{3128,5,3592,3},
        {3133,5,3595,3},{3138,5,3598,12},{3143,5,3610,1},{3148,5,3611,1},{3153,5,3612,1},{3158,5,3613,2},{3163,5,3615,1},
        {3168,5,3616,4},{3173,5,3620,1},{3178,5,3621,1},{3183,5,3622,1},{3188,5,3623,1},{3193,5,3624,3},{3198,5,3627,1},
        {3203,5,3628,1},{3208,5,3629,2},{3213,5,3631,1},{3218,5,3632,1},{3223,5,3633,2},{3228,5,3635,2},{3233,5,3637,2},
        {3238,5,3639,2},{3243,5,3641,1},{3248,5,3642,1},{3253,5,3643,1},{3258,5,3644,1},{3263,5,3645,1},{3268,5,3646,1},
        {3273,5,3647,1},{3278,5,3648,1},{3283,5,3649,2},{3288,5,3651,1},{3293,5,3652,1},{3298,5,3653,2},{3303,5,3655,1},
        {3308,5,3656,1},{3313,5,3657,1},{3318,5,3658,1},{3323,5,3659,1},{3328,5,3660,1},{3333,5,3661,3},{3338,5,3664,1},
        {3343,5,3665,1},{3348,5,3666,4},{3353,5,3670,1},{3358,5,3671,1},{3363,5,3672,1},{3368,5,3673,1},{3373,5,3674,4},
        {3378,5,3678,1},{3383,5,3679,2},{3388,5,3681,1},{3393,5,3682,1},{3398,5,3683,6},{3403,5,3689,2},{3408,5,3691,1},
        {3413,5,3692,1},{3418,5,3693,1},{3423,5,3694,1},{3428,5,3695,1},{3433,5,3696,1},{3438,5,3697,3},{3443,5,3700,5},
        {3448,5,3705,2},{3453,5,3707,1},{3458,5,3708,3},{3463,5,3711,10},{3468,5,3721,1},{3473,5,3722,8},{3478,5,3730,1},
        {3483,5,3731,1},{3488,5,3732,3},{3493,5,3735,2},{3498,5,3737,1},{3503,5,3738,1},{3508,5,3739,4},{3513,5,3743,1},
        {3518,5,3744,1},{3523,5,3745,1},{3528,5,3746,1},{3533,5,3747,1},{3538,5,3748,1},{3543,5,3749,2},{3548,5,3751,1},
        {3553,5,3752,3},{3558,5,3755,1},{3563,5,3756,1},{3568,5,3757,1},{3573,5,3758,2},{3578,5,3760,1},{3583,5,3761,2},
        {3588,5,3763,4},{3593,5,3767,1},{3598,5,3768,1},{3603,5,3769,1},{3608,5,3770,3},{3613,5,3773,2},{3618,5,3775,2},
        {3623,5,3777,2},{3628,5,3779,1},{3633,5,3780,3},{3638,5,3783,2},{3643,5,3785,1},{3648,5,3786,1},{3653,5,3787,1},
        {3658,5,3788,1},{3663,5,3789,1},{3668,5,3790,3},{3673,5,3793,1},{3678,5,3794,1},{3683,5,3795,1},{3688,5,3796,2},
        {3693,5,3798,1},{3698,5,3799,1},{3703,5,3800,1},{3708,5,3801,1},{3713,5,3802,4},{3718,5,3806,1},{3723,5,3807,3},
        {3728,5,3810,3},{3733,5,3813,1},{3738,5,3814,1},{3743,5,3815,1},{3748,5,3816,3},{3753,5,3819,2},{3758,5,3821,1},
        {3763,5,3822,1},{3768,5,3823,3},{3773,5,3826,1},{3778,5,3827,1},{3783,5,3828,1},{3788,5,3829,1},{3793,5,3830,2},
        {3798,5,3832,4},{3803,5,3836,1},{3808,5,3837,1},{3813,5,3838,3},{3818,5,3841,1},{3823,5,3842,1},{3828,5,3843,1},
        {3833,5,3844,1},{3838,5,3845,2},{3843,5,3847,1},{3848,5,3848,2},{3853,5,3850,7},{3858,5,3857,3},{3863,5,3860,2},
        {3868,5,3862,3},{3873,5,3865,4},{3878,5,3869,1},{3883,5,3870,1},{3888,5,3871,2},{3893,5,3873,5},{3898,5,3878,1},
        {3903,5,3879,1},{3908,5,3880,1},{3913,5,3881,1},{3918,5,3882,1},{3923,5,3883,1},{3928,5,3884,1},{3933,5,3885,2},
        {3938,5,3887,3},{3943,5,3890,1},{3948,5,3891,1},{3953,5,3892,3},{3958,5,3895,1},{3963,5,3896,1},{3968,5,3897,1},
        {3973,5,3898,4},{3978,5,3902,1},{3983,5,3903,3},{3988,5,3906,1},{3993,5,3907,1},{3998,5,3908,1},{4003,5,3909,1},
        {4008,5,3910,2},{4013,5,3912,1},{4018,5,3913,1},{4023,5,3914,1},{4028,5,3915,1},{4033,5,3916,1},{4038,5,3917,1},
        {4043,5,3918,1},{4048,5,3919,1},{4053,5,3920,1},{4058,5,3921,3},{4063,5,3924,1},{4068,5,3925,1},{4073,5,3926,1},
        {4078,5,3927,1},{4083,5,3928,1},{4088,5,3929,1},{4093,5,3930,1},{4098,5,3931,3},{4103,5,3934,2},{4108,5,3936,2},
        {4113,5,3938,1},{4118,5,3939,1},{4123,5,3940,6},{4128,5,3946,2},{4133,5,3948,1},{4138,5,3949,1},{4143,5,3950,2},
        {4148,5,3952,2},{4153,5,3954,1},{4158,5,3955,1},{4163,5,3956,1},{4168,5,3957,1},{4173,5,3958,1},{4178,5,3959,2},
        {4183,5,3961,3},{4188,5,3964,4},{4193,5,3968,2},{4198,5,3970,1},{4203,5,3971,3},{4208,5,3974,3},{4213,5,3977,1},
        {4218,5,3978,1},{4223,5,3979,1},{4228,5,3980,1},{4233,5,3981,2},{4238,5,3983,1},{4243,5,3984,1},{4248,5,3985,2},
        {4253,5,3987,2},{4258,5,3989,1},{4263,5,3990,1},{4268,5,3991,1},{4273,5,3992,1},{4278,5,3993,6},{4283,5,3999,3},
        {4288,5,4002,2},{4293,5,4004,5},{4298,5,4009,3},{4303,5,4012,1},{4308,5,4013,5},{4313,5,4018,2},{4318,5,4020,2},
        {4323,5,4022,1},{4328,5,4023,1},{4333,5,4024,1},{4338,5,4025,1},{4343,5,4026,1},{4348,5,4027,1},{4353,5,4028,1},
        {4358,5,4029,1},{4363,5,4030,1},{4368,5,4031,1},{4373,5,4032,1},{4378,5,4033,4},{4383,5,4037,1},{4388,5,4038,2},
        {4393,5,4040,1},{4398,5,4041,11},{4403,5,4052,2},{4408,5,4054,1},{4413,5,4055,1},{4418,5,4056,6},{4423,5,4062,1},
        {4428,5,4063,2},{4433,5,4065,2},{4438,5,4067,1},{4443,5,4068,1},{4448,5,4069,1},{4453,5,4070,1},{4458,5,4071,1},
        {4463,5,4072,1},{4468,5,4073,1},{4473,5,4074,2},{4478,5,4076,1},{4483,5,4077,1},{4488,5,4078,1},{4493,5,4079,1},
        {4498,5,4080,1},{4503,5,4081,1},{4508,5,4082,1},{4513,5,4083,2},{4518,5,4085,1},{4523,5,4086,2},{4528,5,4088,1},
        {4533,5,4089,2},{4538,5,4091,1},{4543,5,4092,1},{4548,5,4093,2},{4553,5,4095,1},{4558,5,4096,1},{4563,5,4097,1},
        {4568,5,4098,1},{4573,5,4099,1},{4578,5,4100,1},{4583,5,4101,1},{4588,5,4102,1},{4593,5,4103,2},{4598,5,4105,1},
        {4603,5,4106,1},{4608,5,4107,2},{4613,5,4109,2},{4618,5,4111,1},{4623,5,4112,1},{4628,5,4113,6},{4633,5,4119,2},
        {4638,5,4121,1},{4643,5,4122,3},{4648,5,4125,2},{4653,5,4127,2},{4658,5,4129,1},{4663,5,4130,1},{4668,5,4131,7},
        {4673,5,4138,1},{4678,5,4139,4},{4683,5,4143,1},{4688,5,4144,1},{4693,5,4145,1},{4698,5,4146,2},{4703,5,4148,1},
        {4708,5,4149,3},{4713,5,4152,1},{4718,5,4153,1},{4723,5,4154,2},{4728,5,4156,2},{4733,5,4158,1},{4738,5,4159,4},
        {4743,5,4163,1},{4748,5,4164,1},{4753,5,4165,1},{4758,5,4166,3},{4763,5,4169,1},{4768,5,4170,1},{4773,5,4171,1},
        {4778,5,4172,1},{4783,5,4173,1},{4788,5,4174,1},{4793,5,4175,1},{4798,5,4176,1},{4803,5,4177,1},{4808,5,4178,1},
        {4813,5,4179,1},{4818,5,4180,2},{4823,5,4182,1},{4828,5,4183,4},{4833,5,4187,1},{4838,5,4188,1},{4843,5,4189,1},
        {4848,5,4190,1},{4853,5,4191,1},{4858,5,4192,1},{4863,5,4193,1},{4868,5,4194,1},{4873,5,4195,1},{4878,5,4196,1},
        {4883,5,4197,3},{4888,5,4200,1},{4893,5,4201,3},{4898,5,4204,2},{4903,5,4206,1},{4908,5,4207,1},{4913,5,4208,2},
        {4918,5,4210,2},{4923,5,4212,1},{4928,5,4213,2},{4933,5,4215,4},{4938,5,4219,2},{4943,5,4221,2},{4948,5,4223,1},
        {4953,5,4224,1},{4958,5,4225,1},{4963,5,4226,1},{4968,5,4227,1},{4973,5,4228,1},{4978,5,4229,1},{4983,5,4230,1},
        {4988,5,4231,2},{4993,5,4233,1},{4998,5,4234,1},{5003,5,4235,6},{5008,5,4241,3},{5013,5,4244,1},{5018,5,4245,1},
        {5023,5,4246,1},{5028,5,4247,3},{5033,5,4250,2},{5038,5,4252,1},{5043,5,4253,1},{5048,5,4254,1},{5053,5,4255,5},
        {5058,5,4260,2},{5063,5,4262,3},{5068,5,4265,1},{5073,5,4266,1},{5078,5,4267,1},{5083,5,4268,1},{5088,5,4269,1},
        {5093,5,4270,1},{5098,5,4271,8},{5103,5,4279,3},{5108,5,4282,1},{5113,5,4283,1},{5118,5,4284,1},{5123,5,4285,5},
        {5128,5,4290,2},{5133,5,4292,2},{5138,5,4294,2},{5143,5,4296,1},{5148,5,4297,2},{5153,5,4299,1},{5158,5,4300,1},
        {5163,5,4301,1},{5168,5,4302,1},{5173,5,4303,1},{5178,5,4304,1},{5183,5,4305,1},{5188,5,4306,1},{5193,5,4307,2},
        {5198,5,4309,1},{5203,5,4310,1},{5208,5,4311,1},{5213,5,4312,1},{5218,5,4313,1},{5223,5,4314,1},{5228,5,4315,1},
        {5233,5,4316,2},{5238,5,4318,2},{5243,5,4320,1},{5248,5,4321,1},{5253,5,4322,1},{5258,5,4323,1},{5263,5,4324,1},
        {5268,5,4325,2},{5273,5,4327,1},{5278,5,4328,1},{5283,5,4329,1},{5288,5,4330,1},{5293,5,4331,6},{5298,5,4337,2},
        {5303,5,4339,1},{5308,5,4340,1},{5313,5,4341,6},{5318,5,4347,1},{5323,5,4348,1},{5328,5,4349,1},{5333,5,4350,1},
        {5338,5,4351,1},{5343,5,4352,2},{5348,5,4354,1},{5353,5,4355,1},{5358,5,4356,1},{5363,5,4357,1},{5368,5,4358,1},
        {5373,5,4359,1},{5378,5,4360,1},{5383,5,4361,1},{5388,5,4362,1},{5393,5,4363,1},{5398,5,4364,1},{5403,5,4365,1},
        {5408,5,4366,1},{5413,5,4367,1},{5418,5,4368,1},{5423,5,4369,1},{5428,5,4370,1},{5433,5,4371,1},{5438,5,4372,1},
        {5443,5,4373,1},{5448,5,4374,1},{5453,5,4375,1},{5458,5,4376,1},{5463,5,4377,1},{5468,5,4378,1},{5473,5,4379,1},
        {5478,5,4380,1},{5483,5,4381,1},{5488,5,4382,1},{5493,5,4383,1},{5498,5,4384,1},{5503,5,4385,1},{5508,5,4386,1},
        {5513,5,4387,1},{5518,5,4388,1},{5523,5,4389,1},{5528,5,4390,1},{5533,5,4391,1},{5538,5,4392,2},{5543,5,4394,1},
        {5548,5,4395,1},{5553,5,4396,7},{5558,5,4403,10},{5563,5,4413,1},{5568,5,4414,1},{5573,5,4415,1},{5578,5,4416,1},
        {5583,5,4417,1},{5588,5,4418,3},{5593,5,4421,1},{5598,5,4422,1},{5603,5,4423,1},{5608,5,4424,1},{5613,5,4425,3},
        {5618,5,4428,1},{5623,5,4429,1},{5628,5,4430,2},{5633,5,4432,1},{5638,5,4433,1},{5643,5,4434,2},{5648,5,4436,1},
        {5653,5,4437,1},{5658,5,4438,1},{5663,5,4439,1},{5668,5,4440,1},{5673,5,4441,2},{5678,5,4443,1},{5683,5,4444,1},
        {5688,5,4445,1},{5693,5,4446,1},{5698,5,4447,1},{5703,5,4448,1},{5708,5,4449,15},{5713,5,4464,15},{5718,5,4479,2},
        {5723,5,4481,1},{5728,5,4482,1},{5733,5,4483,1},{5738,5,4484,2},{5743,5,4486,2},{5748,5,4488,4},{5753,5,4492,1},
        {5758,5,4493,4},{5763,5,4497,5},{5768,5,4502,3},{5773,5,4505,1},{5778,5,4506,1},{5783,5,4507,1},{5788,5,4508,1},
        {5793,5,4509,2},{5798,5,4511,1},{5803,5,4512,1},{5808,5,4513,1},{5813,5,4514,1},{5818,5,4515,1},{5823,5,4516,2},
        {5828,5,4518,1},{5833,5,4519,1},{5838,5,4520,1},{5843,5,4521,1},{5848,5,4522,2},{5853,5,4524,1},{5858,5,4525,1},
        {5863,5,4526,2},{5868,5,4528,2},{5873,5,4530,2},{5878,5,4532,1},{5883,5,4533,1},{5888,5,4534,1},{5893,5,4535,1},
        {5898,5,4536,1},{5903,5,4537,2},{5908,5,4539,6},{5913,5,4545,3},{5918,5,4548,3},{5923,5,4551,1},{5928,5,4552,4},
        {5933,5,4556,7},{5938,5,4563,6},{5943,5,4569,1},{5948,5,4570,3},{5953,5,4573,1},{5958,5,4574,3},{5963,5,4577,2},
        {5968,5,4579,3},{5973,5,4582,3},{5978,5,4585,3},{5983,5,4588,1},{5988,5,4589,1},{5993,5,4590,1},{5998,5,4591,2},
        {6003,5,4593,2},{6008,5,4595,2},{6013,5,4597,1},{6018,5,4598,1},{6023,5,4599,2},{6028,5,4601,1},{6033,5,4602,2},
        {6038,5,4604,1},{6043,5,4605,1},{6048,5,4606,1},{6053,5,4607,1},{6058,5,4608,1},{6063,5,4609,1},{6068,5,4610,1},
        {6073,5,4611,1},{6078,5,4612,1},{6083,5,4613,1},{6088,5,4614,1},{6093,5,4615,2},{6098,5,4617,2},{6103,5,4619,1},
        {6108,5,4620,3},{6113,5,4623,1},{6118,5,4624,1},{6123,5,4625,1},{6128,5,4626,1},{6133,5,4627,1},{6138,5,4628,1},
        {6143,5,4629,1},{6148,5,4630,1},{6153,5,4631,3},{6158,5,4634,1},{6163,5,4635,1},{6168,5,4636,1},{6173,5,4637,1},
        {6178,5,4638,3},{6183,5,4641,1},{6188,5,4642,3},{6193,5,4645,1},{6198,5,4646,3},{6203,5,4649,1},{6208,5,4650,1},
        {6213,5,4651,1},{6218,5,4652,1},{6223,5,4653,1},{6228,5,4654,3},{6233,5,4657,4},{6238,5,4661,2},{6243,5,4663,2},
        {6248,5,4665,3},{6253,5,4668,1},{6258,5,4669,2},{6263,5,4671,2},{6268,5,4673,2},{6273,5,4675,3},{6278,5,4678,2},
        {6283,5,4680,1},{6288,5,4681,1},{6293,5,4682,1},{6298,5,4683,1},{6303,5,4684,1},{6308,5,4685,1},{6313,5,4686,1},
        {6318,5,4687,1},{6323,5,4688,1},{6328,5,4689,1},{6333,5,4690,1},{6338,5,4691,4},{6343,5,4695,1},{6348,5,4696,4},
        {6353,5,4700,3},{6358,5,4703,1},{6363,5,4704,1},{6368,5,4705,2},{6373,5,4707,1},{6378,5,4708,1},{6383,5,4709,2},
        {6388,5,4711,4},{6393,5,4715,3},{6398,5,4718,5},{6403,5,4723,6},{6408,5,4729,1},{6413,5,4730,5},
    };
}
class opnbo{
    public:
    bool lodbu(int bookp,bool expsy){
        mmaxp=std::max(0,std::min(bookp,(int)btnbk::maxpl));
        usesy=expsy;
        entri.clear();
        constexpr size_t entcn=sizeof(btnbk::entri)/sizeof(btnbk::entri[0]);
        entri.reserve(entcn*(usesy?2u:1u));
        for(const auto&e:btnbk::entri){
            if((int)e.pfxle>=mmaxp){
                continue;
            }
            const uint8_t*pref=btnbk::pfxpo+e.pfxof;
            const uint8_t*moves=btnbk::movpo+e.movof;
            if(!usesy){
                uint64_t key=encby(pref,(int)e.pfxle);
                for(int i=0;i<(int)e.movle;i++){
                    insca(key,(uint16_t)moves[i]);
                }
            }else{
                uint8_t tp[12];
                for(int sym=0;sym<8;sym++){
                    for(int i=0;i<(int)e.pfxle;i++){
                        tp[i]=(uint8_t)appsy((uint16_t)pref[i],sym);
                    }
                    uint64_t key=encby(tp,(int)e.pfxle);
                    for(int i=0;i<(int)e.movle;i++){
                        uint16_t code=appsy((uint16_t)moves[i],sym);
                        insca(key,code);
                    }
                }
            }
        }
        return!entri.empty();
    }
    bool load(const std::string&,int bookp,bool expsy){
        return lodbu(bookp,expsy);
    }
    bool probe(const std::vector<move0>&hist,int bookp,move0&out) const{
        int ply=(int)hist.size();
        if(bookp<=0){
            return false;
        }
        if(ply>=bookp){
            return false;
        }
        uint64_t key=enchi(hist,ply);
        auto it=entri.find(key);
        if(it==entri.end()||it->second.empty()){
            return false;
        }
        static thread_local std::mt19937_64 rng(seed0());
        std::uniform_int_distribution<size_t>dist(0,it->second.size()-1);
        size_t start=dist(rng);
        for(size_t k=0;k<it->second.size();k++){
            uint16_t code=it->second[(start+k)%it->second.size()];
            int r=(int)(code/n);
            int c=(int)(code%n);
            if(!dist3(hist,r,c)){
                continue;
            }
            out={r,c,0};
            return true;
        }
        return false;
    }
    size_t pfxcn() const{
        return entri.size();
    }
    int maply() const{
        return mmaxp;
    }
    private:
    static inline uint64_t seed0(){
        uint64_t t=(uint64_t)std::chrono::high_resolution_clock::now().time_since_epoch().count();
        t^=(uint64_t)(uintptr_t)&t;
        t^=(uint64_t)std::hash<std::thread::id>{}(std::this_thread::get_id());
        t^=0x9e3779b97f4a7c15ull;
        return t;
    }
    static inline bool dist3(const std::vector<move0>&hist,int r,int c){
        if(hist.empty()){
            return true;
        }
        for(const auto&m:hist){
            int dr=r-m.r;
            int dc=c-m.c;
            if(dr*dr+dc*dc<=4){
                return true;
            }
        }
        return false;
    }
    int mmaxp=6;
    bool usesy=true;
    std::unordered_map<uint64_t,std::vector<uint16_t>>entri;
    static inline uint64_t enchi(const std::vector<move0>&hist,int ply){
        uint64_t k=(uint64_t)(ply&0xFF)<<56;
        for(int i=0;i<ply&&i<12;i++){
            uint8_t code=(uint8_t)(hist[i].r*n+hist[i].c);
            k|=(uint64_t)code<<(8*i);
        }
        return k;
    }
    static inline uint64_t encby(const uint8_t*seq,int len){
        uint64_t k=(uint64_t)(len&0xFF)<<56;
        for(int i=0;i<len&&i<12;i++){
            k|=(uint64_t)(seq[i]&0xFF)<<(8*i);
        }
        return k;
    }
    static inline uint16_t appsy(uint16_t code,int sym){
        int r=code/n;
        int c=code%n;
        int rr=r,cc=c;
        switch(sym){
            case 0:
            rr=r;
            cc=c;
            break;
            case 1:
            rr=c;
            cc=n-1-r;
            break;
            case 2:
            rr=n-1-r;
            cc=n-1-c;
            break;
            case 3:
            rr=n-1-c;
            cc=r;
            break;
            case 4:
            rr=r;
            cc=n-1-c;
            break;
            case 5:
            rr=n-1-r;
            cc=c;
            break;
            case 6:
            rr=c;
            cc=r;
            break;
            case 7:
            rr=n-1-c;
            cc=n-1-r;
            break;
            default:
            rr=r;
            cc=c;
            break;
        }
        return(uint16_t)(rr*n+cc);
    }
    inline void insca(uint64_t key,uint16_t nxt){
        auto&v=entri[key];
        for(auto x:v){
            if(x==nxt){
                return;
            }
        }
        v.push_back(nxt);
    }
};
class engin{
    public:
    engin(size_t tt_mb=32,shared_ptr<tttab>share=nullptr){
        shared0::inion();
        if(share){
            tt=share;
        }else{
            tt=make_shared<tttab>();
            tt->inimb(tt_mb);
        }
        reset();
    }
    void reset(){
        for(int r=0;r<n;r++){
            for(int c=0;c<n;c++){
                board[r][c]=eempt;
            }
        }
        movst.clear();
        hshst=0;
        memset(histo,0,sizeof(histo));
        for(int p=0;p<maxpl;p++){
            kils[p][0]={-1,-1};
            kils[p][1]={-1,-1};
        }
        memset(linsc,0,sizeof(linsc));
        totsc[0]=totsc[1]=0;
        reale();
        memset(rowma,0,sizeof(rowma));
        memset(colma,0,sizeof(colma));
        memset(digms,0,sizeof(digms));
        memset(anmsk,0,sizeof(anmsk));
        ttgen=tt->newsr();
    }
    void seopb(std::shared_ptr<const opnbo>b){
        book=std::move(b);
    }
    void cpyfr(const engin&o){
        memcpy(board,o.board,sizeof(board));
        movst=o.movst;
        hshst=o.hshst;
        memcpy(linsc,o.linsc,sizeof(linsc));
        totsc[0]=o.totsc[0];
        totsc[1]=o.totsc[1];
        memcpy(rowma,o.rowma,sizeof(rowma));
        memcpy(colma,o.colma,sizeof(colma));
        memcpy(digms,o.digms,sizeof(digms));
        memcpy(anmsk,o.anmsk,sizeof(anmsk));
        book=o.book;
    }
    int movcn() const{
        return(int)movst.size();
    }
    bool isleg(int r,int c) const{
        return inb(r,c)&&board[r][c]==eempt;
    }
    bool place(int r,int c,int color){
        if(!inb(r,c)||board[r][c]!=eempt){
            return false;
        }
        board[r][c]=color;
        hshst^=shared0::zobri[r][c][color==black?0:1];
        relii(shared0::libar+r);
        relii(shared0::libac+c);
        relii(shared0::libad+(r-c+(n-1)));
        relii(shared0::libaa+(r+c));
        bbtog(r,c,color);
        movst.push_back({r,c,0});
        return true;
    }
    void undo(){
        if(movst.empty()){
            return;
        }
        move0 m=movst.back();
        movst.pop_back();
        int color=board[m.r][m.c];
        board[m.r][m.c]=eempt;
        hshst^=shared0::zobri[m.r][m.c][color==black?0:1];
        relii(shared0::libar+m.r);
        relii(shared0::libac+m.c);
        relii(shared0::libad+(m.r-m.c+(n-1)));
        relii(shared0::libaa+(m.r+m.c));
        bbtog(m.r,m.c,color);
    }
    bool lamow() const{
        if(movst.empty()){
            return false;
        }
        auto m=movst.back();
        int color=board[m.r][m.c];
        return bbwia(m.r,m.c,color);
    }
    string coost(int r,int c) const{
        string s;
        s.push_back(char('A'+c));
        s+=to_string(r+1);
        return s;
    }
    void prbop() const{
        cout<<"    ";
        for(int c=0;c<n;c++){
            cout<<"  "<<char('A'+c);
        }
        cout<<"\n";
        int lr=-1,lc=-1;
        int lcol=eempt;
        if(!movst.empty()){
            lr=movst.back().r;
            lc=movst.back().c;
            lcol=board[lr][lc];
        }
        for(int r=0;r<n;r++){
            cout<<setw(2)<<(r+1)<<"  ";
            for(int c=0;c<n;c++){
                char ch='.';
                if(board[r][c]==black){
                    ch='X';
                }else{
                    if(board[r][c]==white){
                        ch='O';
                    }
                }
                if(r==lr&&c==lc){
                    if(ch=='X'){
                        ch='x';
                    }else{
                        if(ch=='O'){
                            ch='o';
                        }
                    }
                }
                cout<<"  "<<ch;
            }
            cout<<"\n";
        }
        if(lr!=-1){
            cout<<"Last move: "<<(lcol==black?'X':'O')<<" at "<<char('A'+lc)<<(lr+1)<<"\n";
        }
    }
    void cfgtt(bool usepe){
        if(tt){
            tt->seusp(usepe);
        }
    }
    bool ttpeo() const{
        return tt?tt->geusp():false;
    }
    move0 think(int side,const srchl&lim,bool verbo=true){
        limit=lim;
        if(limit.usebo&&book&&(int)movst.size()<limit.boply){
            move0 bm;
            if(book->probe(movst,limit.boply,bm)&&isleg(bm.r,bm.c)){
                if(verbo){
                    cout<<"[BOOK] "<<coost(bm.r,bm.c)<<" (ply "<<((int)movst.size()+1)<<"/"<<limit.boply<<")\n";
                    cout.flush();
                }
                return bm;
            }
        }
        if(movst.empty()){
            return{n/2,n/2,0};
        }
        start=chrono::steady_clock::now();
        ddl=start+chrono::milliseconds(limit.timms);
        stopf.store(false);
        stats={};
        ttgen=tt->newsr();
        if(limit.usedf){
            int budms=min(limit.timms/4,2500);
            move0 best;
            vector<move0>pv;
            if(dfpso(side,budms,350000,best,pv)){
                if(verbo){
                    cout<<"[DFPN] Forced win. Best="<<coost(best.r,best.c)<<" PV:";
                    for(auto&m:pv){
                        cout<<" "<<coost(m.r,m.c);
                    }
                    cout<<"\n";
                    cout.flush();
                }
                return best;
            }
        }
        move0 best{n/2,n/2,-inf};
        vector<pair<move0,int>>lastt;
        int aspir=40'000;
        int prevs=0;
        int threa=limit.threa;
        if(threa<=0){
            threa=(int)std::thread::hardware_concurrency();
            if(threa<=0){
                threa=1;
            }
        }
        threa=max(1,min(threa,16));
        for(int depth=1;depth<=30;depth++){
            if(timup()){
                break;
            }
            int alpha=-inf,beta=inf;
            if(depth>=3){
                alpha=max(-inf,prevs-aspir);
                beta=min(inf,prevs+aspir);
            }
            vector<pair<move0,int>>topmo;
            int score=0;
            bool done=false;
            for(int attem=0;attem<3&&!done;attem++){
                pair<move0,int>res;
                if(threa==1){
                    res=rosrs(side,depth,alpha,beta,topmo,verbo);
                }else{
                    res=rosrp(side,depth,alpha,beta,topmo,verbo,threa);
                }
                if(stopf.load()){
                    break;
                }
                best=res.first;
                score=res.second;
                if(score<=alpha){
                    alpha=-inf;
                    aspir*=2;
                }else{
                    if(score>=beta){
                        beta=inf;
                        aspir*=2;
                    }else{
                        done=true;
                    }
                }
            }
            if(stopf.load()){
                break;
            }
            prevs=score;
            lastt=topmo;
            if(verbo){
                double ms=elams();
                double nps=ms>0?(stats.nodes*1000.0/ms):0;
                cout<<"\n[Depth "<<depth<<"] Score="<<score<<"  Best="<<coost(best.r,best.c)<<"  Nodes="<<stats.nodes<<"  QNodes="<<stats.qnode<<"  NPS="<<(uint64_t)nps<<"  Time="<<(uint64_t)ms<<"ms\n";
                auto pv=extpv(side,depth);
                if(!pv.empty()){
                    cout<<"PV:";
                    for(auto&m:pv){
                        cout<<" "<<coost(m.r,m.c);
                    }
                    cout<<"\n";
                }
                cout<<"Top moves:";
                int k=min<int>(6,(int)lastt.size());
                for(int i=0;i<k;i++){
                    cout<<"  "<<coost(lastt[i].first.r,lastt[i].first.c)<<":"<<lastt[i].second;
                }
                cout<<"\n";
                cout.flush();
            }
        }
        return best;
    }
    private:
    int board[n][n]{
    };
    vector<move0>movst;
    uint64_t hshst=0;
    shared_ptr<tttab>tt;
    uint16_t ttgen=1;
    std::shared_ptr<const opnbo>book;
    static constexpr int maxpl=64;
    pair<int,int>kils[maxpl][2];
    int histo[2][n][n];
    int linsc[2][shared0::lincn]{
    };
    int totsc[2]{
    };
    uint16_t rowma[2][n]{
    };
    uint16_t colma[2][n]{
    };
    uint16_t digms[2][2*n-1]{
    };
    uint16_t anmsk[2][2*n-1]{
    };
    srchl limit;
    srchs stats;
    chrono::steady_clock::time_point start;
    chrono::steady_clock::time_point ddl;
    atomic<bool>stopf{false};
    inline double elams() const{
        return chrono::duration<double,milli>(chrono::steady_clock::now()-start).count();
    }
    inline bool timup() const{
        return chrono::steady_clock::now()>=ddl;
    }
    inline int sidid(int side) const{
        return(side==black)?0:1;
    }
    inline uint64_t ttkey(int sidet) const{
        return hshst^(sidet==black?shared0::zside:0ULL);
    }
    int sclii(int linei,int side) const{
        const auto&cells=shared0::lince[linei];
        int l0=(int)cells.size();
        if(l0<5){
            return 0;
        }
        int extle=l0+2;
        int digit[17];
        digit[0]=2;
        for(int i=0;i<l0;i++){
            auto[rr,cc]=cells[i];
            int v=board[rr][cc];
            if(v==eempt){
                digit[i+1]=0;
            }else{
                if(v==side){
                    digit[i+1]=1;
                }else{
                    digit[i+1]=2;
                }
            }
        }
        digit[extle-1]=2;
        int code=0;
        for(int j=0;j<7;j++){
            code+=digit[j]*shared0::pow3[j];
        }
        int total=0;
        for(int i=0;i+7<=extle;i++){
            total+=shared0::win7[code];
            if(total>=winsc){
                return winsc;
            }
            if(i+7==extle){
                break;
            }
            code=(code-digit[i])/3+digit[i+7]*shared0::pow3[6];
        }
        return total;
    }
    void relii(int linei){
        totsc[0]-=linsc[0][linei];
        totsc[1]-=linsc[1][linei];
        linsc[0][linei]=sclii(linei,black);
        linsc[1][linei]=sclii(linei,white);
        totsc[0]+=linsc[0][linei];
        totsc[1]+=linsc[1][linei];
    }
    void reale(){
        totsc[0]=totsc[1]=0;
        for(int lid=0;lid<shared0::lincn;lid++){
            linsc[0][lid]=sclii(lid,black);
            linsc[1][lid]=sclii(lid,white);
            totsc[0]+=linsc[0][lid];
            totsc[1]+=linsc[1][lid];
        }
    }
    int evalu(int sidet) const{
        int my=(sidet==black?totsc[0]:totsc[1]);
        int op=(sidet==black?totsc[1]:totsc[0]);
        if(my>=winsc){
            return winsc;
        }
        if(op>=winsc){
            return-winsc;
        }
        return my-(int)(op*1.08);
    }
    inline void bbtog(int r,int c,int color){
        int si=(color==black)?0:1;
        rowma[si][r]^=(uint16_t)(1u<<c);
        colma[si][c]^=(uint16_t)(1u<<r);
        int d=shared0::digid(r,c);
        digms[si][d]^=(uint16_t)(1u<<shared0::digpo(r,d));
        int s=shared0::anidx(r,c);
        anmsk[si][s]^=(uint16_t)(1u<<shared0::anpos(r,s));
    }
    static inline bool hasfi(uint16_t m){
        return(m&(m>>1)&(m>>2)&(m>>3)&(m>>4))!=0;
    }
    inline bool bbwia(int r,int c,int color) const{
        int si=(color==black)?0:1;
        if(hasfi(rowma[si][r])){
            return true;
        }
        if(hasfi(colma[si][c])){
            return true;
        }
        int d=shared0::digid(r,c);
        if(shared0::digl[d]>=5&&hasfi(digms[si][d])){
            return true;
        }
        int s=shared0::anidx(r,c);
        if(shared0::anlen[s]>=5&&hasfi(anmsk[si][s])){
            return true;
        }
        return false;
    }
    bool wouwi(int r,int c,int color) const{
        if(!inb(r,c)||board[r][c]!=eempt){
            return false;
        }
        int si=(color==black)?0:1;
        uint16_t rm=rowma[si][r]|(uint16_t)(1u<<c);
        if(hasfi(rm)){
            return true;
        }
        uint16_t cm=colma[si][c]|(uint16_t)(1u<<r);
        if(hasfi(cm)){
            return true;
        }
        int d=shared0::digid(r,c);
        if(shared0::digl[d]>=5){
            uint16_t dm=digms[si][d]|(uint16_t)(1u<<shared0::digpo(r,d));
            if(hasfi(dm)){
                return true;
            }
        }
        int s=shared0::anidx(r,c);
        if(shared0::anlen[s]>=5){
            uint16_t am=anmsk[si][s]|(uint16_t)(1u<<shared0::anpos(r,s));
            if(hasfi(am)){
                return true;
            }
        }
        return false;
    }
    vector<move0>genba(int radiu) const{
        if(movst.empty()){
            return{{n/2,n/2,0}};
        }
        static constexpr uint16_t full=(uint16_t)((1u<<n)-1u);
        uint16_t occro[n];
        for(int r=0;r<n;r++){
            occro[r]=(uint16_t)(rowma[0][r]|rowma[1][r]);
        }
        vector<move0>cand;
        cand.reserve(256);
        for(int r=0;r<n;r++){
            uint16_t nearm=0;
            for(int dr=-radiu;dr<=radiu;dr++){
                int rr=r+dr;
                if(rr<0||rr>=n){
                    continue;
                }
                uint16_t m=occro[rr];
                uint16_t sprea=m;
                for(int s=1;s<=radiu;s++){
                    sprea|=(uint16_t)((m<<s)|(m>>s));
                }
                nearm|=(uint16_t)(sprea&full);
            }
            uint16_t empty=(uint16_t)((~occro[r])&full);
            uint16_t mask=(uint16_t)(nearm&empty);
            while(mask){
                int c=__builtin_ctz((unsigned)mask);
                mask&=(uint16_t)(mask-1);
                cand.push_back({r,c,0});
            }
        }
        if(cand.empty()){
            cand.push_back({n/2,n/2,0});
        }
        return cand;
    }
    int poihe(int r,int c,int side) const{
        static const int dr0[4]={1,0,1,1};
        static const int dc0[4]={0,1,1,-1};
        auto cntco=[&](int dr,int dc,int color,int sr,int sc)->int{
            int cnt=0;
            int rr=sr+dr,cc=sc+dc;
            while(inb(rr,cc)&&board[rr][cc]==color){
                cnt++;
                rr+=dr;
                cc+=dc;
            }
            return cnt;
        };
        auto isopn=[&](int rr,int cc)->bool{
            return inb(rr,cc)&&board[rr][cc]==eempt;
        };
        int total=0;
        int stron=0;
        for(int k=0;k<4;k++){
            int dr=dr0[k],dc=dc0[k];
            int l0=cntco(-dr,-dc,side,r,c);
            int r0=cntco(dr,dc,side,r,c);
            int lr=r-(l0+1)*dr,lc=c-(l0+1)*dc;
            int rr=r+(r0+1)*dr,rc=c+(r0+1)*dc;
            int opnen=(isopn(lr,lc)?1:0)+(isopn(rr,rc)?1:0);
            int conti=l0+1+r0;
            int l2=0,r2=0;
            if(inb(lr,lc)&&board[lr][lc]==eempt){
                int rr2=lr-dr,cc2=lc-dc;
                while(inb(rr2,cc2)&&board[rr2][cc2]==side){
                    l2++;
                    rr2-=dr;
                    cc2-=dc;
                }
            }
            if(inb(rr,rc)&&board[rr][rc]==eempt){
                int rr2=rr+dr,cc2=rc+dc;
                while(inb(rr2,cc2)&&board[rr2][cc2]==side){
                    r2++;
                    rr2+=dr;
                    cc2+=dc;
                }
            }
            int onega=max(conti,max((l0+l2)+1+r0,l0+1+(r0+r2)));
            int s=0;
            if(conti>=5){
                s=winsc;
            }else{
                if(conti==4&&opnen==2){
                    s=1'200'000;
                }else{
                    if(conti==4&&opnen==1){
                        s=220'000;
                    }else{
                        if(onega==4&&opnen>=1){
                            s=170'000;
                        }else{
                            if(conti==3&&opnen==2){
                                s=22'000;
                            }else{
                                if((conti==3&&opnen==1)||(onega==3&&opnen>=1)){
                                    s=7'000;
                                }else{
                                    if(conti==2&&opnen==2){
                                        s=700;
                                    }else{
                                        if(conti==2&&opnen==1){
                                            s=220;
                                        }else{
                                            if(conti==1&&opnen==2){
                                                s=60;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            total+=s;
            if(s>=170'000){
                stron++;
            }
        }
        if(stron>=2){
            total+=250'000;
        }
        return total;
    }
    vector<move0>genca(int sidet){
        int radiu=(movcn()<10?2:3);
        auto cand=genba(radiu);
        vector<move0>winmo;
        winmo.reserve(8);
        for(auto&m:cand){
            if(wouwi(m.r,m.c,sidet)){
                move0 mm=m;
                mm.h=winsc;
                winmo.push_back(mm);
            }
        }
        if(!winmo.empty()){
            return winmo;
        }
        int opp=-sidet;
        vector<move0>bbloc;
        bbloc.reserve(16);
        for(auto&m:cand){
            if(wouwi(m.r,m.c,opp)){
                move0 mm=m;
                int a=poihe(mm.r,mm.c,sidet);
                int b=poihe(mm.r,mm.c,opp);
                mm.h=b*5+a*2;
                bbloc.push_back(mm);
            }
        }
        if(!bbloc.empty()){
            sort(bbloc.begin(),bbloc.end(),[](const move0&x,const move0&y){
                return x.h>y.h;
            }
            );
            if((int)bbloc.size()>24){
                bbloc.resize(24);
            }
            return bbloc;
        }
        vector<move0>vctbl;
        if(hathr(opp)){
            vctbl=colde(opp);
        }
        if(!vctbl.empty()){
            bool havec=false;
            for(auto&m:cand){
                int a=poihe(m.r,m.c,sidet);
                if(a>=170'000){
                    havec=true;
                    break;
                }
            }
            if(!havec||(int)vctbl.size()>=3){
                return vctbl;
            }
        }
        bool seen[n*n]{
        };
        auto pusun=[&](vector<move0>&dst,const move0&m){
            int idx=m.r*n+m.c;
            if(idx<0||idx>=n*n){
                return;
            }
            if(seen[idx]){
                return;
            }
            if(board[m.r][m.c]!=eempt){
                return;
            }
            seen[idx]=true;
            dst.push_back(m);
        };
        vector<move0>out;
        out.reserve(64);
        for(auto m:vctbl){
            m.h+=650'000;
            pusun(out,m);
        }
        vector<move0>thrs;
        thrs.reserve(48);
        vector<move0>quiet;
        quiet.reserve(128);
        for(auto&m0:cand){
            move0 m=m0;
            int a=poihe(m.r,m.c,sidet);
            int b=poihe(m.r,m.c,opp);
            int ctr=30-(abs(m.r-n/2)+abs(m.c-n/2));
            bool stroa=(a>=170'000);
            bool sstro=(b>=170'000);
            if(stroa||sstro){
                m.h=a*3+b*4+ctr+(stroa?200'000:0)+(sstro?120'000:0);
                thrs.push_back(m);
            }else{
                m.h=a*2+b*3+ctr;
                quiet.push_back(m);
            }
        }
        auto byh=[](const move0&x,const move0&y){
            return x.h>y.h;
        };
        sort(thrs.begin(),thrs.end(),byh);
        sort(quiet.begin(),quiet.end(),byh);
        int cap0=(movcn()<14?30:42);
        int capth=(movcn()<14?14:20);
        for(int i=0;i<(int)thrs.size()&&(int)out.size()<cap0&&i<capth;i++){
            pusun(out,thrs[i]);
        }
        for(int i=0;i<(int)quiet.size()&&(int)out.size()<cap0;i++){
            pusun(out,quiet[i]);
        }
        if(out.empty()){
            return cand;
        }
        return out;
    }
    vector<move0>extpv(int sidet,int maxle){
        vector<move0>pv;
        pv.reserve(maxle);
        int side=sidet;
        int pplac=0;
        for(int i=0;i<maxle;i++){
            uint8_t br=255,bc=255;
            if(!tt->getbs(ttkey(side),br,bc)){
                break;
            }
            if(br==255||bc==255){
                break;
            }
            if(!inb(br,bc)||board[br][bc]!=eempt){
                break;
            }
            place((int)br,(int)bc,side);
            pv.push_back({(int)br,(int)bc,0});
            pplac++;
            if(lamow()){
                break;
            }
            side=-side;
        }
        for(int i=0;i<pplac;i++){
            undo();
        }
        return pv;
    }
    bool iskil(int ply,const move0&m) const{
        if(ply<0||ply>=maxpl){
            return false;
        }
        return(kils[ply][0].first==m.r&&kils[ply][0].second==m.c)||(kils[ply][1].first==m.r&&kils[ply][1].second==m.c);
    }
    void addki(int ply,const move0&m){
        if(ply<0||ply>=maxpl){
            return;
        }
        if(kils[ply][0].first==m.r&&kils[ply][0].second==m.c){
            return;
        }
        kils[ply][1]=kils[ply][0];
        kils[ply][0]={m.r,m.c};
    }
    void ordmo(vector<move0>&moves,int sidet,int ply,uint8_t ttr,uint8_t ttc){
        int si=sidid(sidet);
        for(auto&m:moves){
            int bonus=0;
            if(m.r==(int)ttr&&m.c==(int)ttc){
                bonus+=5'000'000;
            }
            if(iskil(ply,m)){
                bonus+=600'000;
            }
            bonus+=histo[si][m.r][m.c];
            m.h+=bonus;
        }
        sort(moves.begin(),moves.end(),[](const move0&a,const move0&b){
            return a.h>b.h;
        }
        );
    }
    bool opwin(int sidet){
        int opp=-sidet;
        auto cand=genba(3);
        for(auto&m:cand){
            if(wouwi(m.r,m.c,opp)){
                return true;
            }
        }
        return false;
    }
    bool hawis(int side,int radiu){
        auto cand=genba(radiu);
        for(auto&m:cand){
            if(wouwi(m.r,m.c,side)){
                return true;
            }
        }
        return false;
    }
    bool hathr(int attac){
        for(int lid=0;lid<shared0::lincn;lid++){
            const auto&cells=shared0::lince[lid];
            int l0=(int)cells.size();
            if(l0<5){
                continue;
            }
            int extle=l0+2;
            int d[17];
            d[0]=2;
            for(int i=0;i<l0;i++){
                auto[rr,cc]=cells[i];
                int v=board[rr][cc];
                d[i+1]=(v==eempt?0:(v==attac?1:2));
            }
            d[extle-1]=2;
            for(int i=0;i+5<=extle;i++){
                if(d[i]==0&&d[i+1]==1&&d[i+2]==1&&d[i+3]==1&&d[i+4]==0){
                    return true;
                }
                if(i+6<=extle){
                    if(d[i]==0&&d[i+1]==1&&d[i+2]==1&&d[i+3]==0&&d[i+4]==1&&d[i+5]==0){
                        return true;
                    }
                    if(d[i]==0&&d[i+1]==1&&d[i+2]==0&&d[i+3]==1&&d[i+4]==1&&d[i+5]==0){
                        return true;
                    }
                }
            }
        }
        return false;
    }
    int qsear(int alpha,int beta,int sidet,int ply){
        stats.qnode++;
        if((stats.qnode&2047u)==0u&&timup()){
            stopf.store(true);
            return 0;
        }
        int stand=evalu(sidet);
        if(stand>=beta){
            return stand;
        }
        alpha=max(alpha,stand);
        auto cand=genba(3);
        vector<move0>moves;
        moves.reserve(48);
        bool seen[n*n]{
        };
        auto addun=[&](move0 m){
            int idx=m.r*n+m.c;
            if(idx<0||idx>=n*n){
                return;
            }
            if(seen[idx]){
                return;
            }
            seen[idx]=true;
            moves.push_back(m);
        };
        for(auto&m:cand){
            if(wouwi(m.r,m.c,sidet)){
                m.h=winsc;
                addun(m);
                continue;
            }
            if(wouwi(m.r,m.c,-sidet)){
                m.h=950'000;
                addun(m);
                continue;
            }
        }
        if(hathr(-sidet)){
            auto vctbl=colde(-sidet);
            for(auto&m:vctbl){
                move0 mm=m;
                mm.h+=650'000;
                addun(mm);
            }
        }
        for(auto&m:cand){
            int h=poihe(m.r,m.c,sidet);
            if(h>=170'000){
                move0 mm=m;
                mm.h=h;
                addun(mm);
            }
        }
        if(moves.empty()){
            return stand;
        }
        sort(moves.begin(),moves.end(),[](const move0&a,const move0&b){
            return a.h>b.h;
        }
        );
        if((int)moves.size()>14){
            moves.resize(14);
        }
        for(auto&m:moves){
            if(stopf.load()){
                break;
            }
            place(m.r,m.c,sidet);
            int val;
            if(lamow()){
                val=winsc-ply;
            }else{
                val=-qsear(-beta,-alpha,-sidet,ply+1);
            }
            undo();
            if(val>=beta){
                return val;
            }
            alpha=max(alpha,val);
        }
        return alpha;
    }
    int negam(int depth,int alpha,int beta,int sidet,int ply,bool allow){
        stats.nodes++;
        if((stats.nodes&2047u)==0u&&timup()){
            stopf.store(true);
            return 0;
        }
        if(!movst.empty()){
            auto lm=movst.back();
            int lasts=board[lm.r][lm.c];
            if(bbwia(lm.r,lm.c,lasts)){
                return-winsc+ply;
            }
        }
        if(depth<=0){
            return qsear(alpha,beta,sidet,ply);
        }
        uint64_t key=ttkey(sidet);
        uint8_t ttr=255,ttc=255;
        int ttval=0;
        int aalph=alpha;
        if(tt->looku(key,depth,alpha,beta,ttval,ttr,ttc)){
            return ttval;
        }
        if(limit.usenu&&allow&&depth>=3&&ply>=1){
            if(!opwin(sidet)){
                int r0=2+depth/4;
                int newde=depth-1-r0;
                if(newde<0){
                    newde=0;
                }
                int v=-negam(newde,-beta,-beta+1,-sidet,ply+1,false);
                if(stopf.load()){
                    return 0;
                }
                if(v>=beta){
                    tt->store(key,depth,v,1,255,255,ttgen);
                    return v;
                }
            }
        }
        auto moves=genca(sidet);
        ordmo(moves,sidet,min(ply,maxpl-1),ttr,ttc);
        int bsval=-inf;
        uint8_t bestr=255,bestc=255;
        bool first=true;
        for(int i=0;i<(int)moves.size();i++){
            if(stopf.load()){
                break;
            }
            const move0&m=moves[i];
            bool tacti=(m.h>=350'000);
            place(m.r,m.c,sidet);
            int ext=0;
            if(!stopf.load()&&depth>=2&&tacti){
                if(hawis(sidet,3)){
                    ext=1;
                }else{
                    if(depth>=3&&hathr(sidet)){
                        ext=1;
                    }
                }
            }
            int val;
            if(lamow()){
                val=winsc-ply;
            }else{
                if(first){
                    val=-negam((depth-1)+ext,-beta,-alpha,-sidet,ply+1,true);
                }else{
                    int newde=depth-1;
                    if(!tacti&&depth>=4&&i>=5){
                        newde=max(1,newde-1);
                    }
                    val=-negam(newde+ext,-(alpha+1),-alpha,-sidet,ply+1,true);
                    if(!stopf.load()&&val>alpha){
                        val=-negam((depth-1)+ext,-beta,-alpha,-sidet,ply+1,true);
                    }
                }
            }
            undo();
            if(stopf.load()){
                break;
            }
            if(val>bsval){
                bsval=val;
                bestr=(uint8_t)m.r;
                bestc=(uint8_t)m.c;
            }
            if(val>alpha){
                alpha=val;
                if(!tacti){
                    histo[sidid(sidet)][m.r][m.c]+=depth*depth;
                }
            }
            if(alpha>=beta){
                if(!tacti){
                    addki(ply,m);
                }
                break;
            }
            first=false;
        }
        uint8_t flag=0;
        if(bsval<=aalph){
            flag=2;
        }else{
            if(bsval>=beta){
                flag=1;
            }else{
                flag=0;
            }
        }
        tt->store(key,depth,bsval,flag,bestr,bestc,ttgen);
        return bsval;
    }
    pair<move0,int>rosrs(int sidet,int depth,int alpha,int beta,vector<pair<move0,int>>&topmo,bool verbo){
        auto moves=genca(sidet);
        uint8_t ttr=255,ttc=255;
        tt->getbs(ttkey(sidet),ttr,ttc);
        ordmo(moves,sidet,0,ttr,ttc);
        move0 bsmov=moves[0];
        int bssco=-inf;
        int srche=0;
        int total=(int)moves.size();
        for(auto&m:moves){
            if(stopf.load()){
                break;
            }
            if((stats.nodes&2047u)==0u&&timup()){
                stopf.store(true);
                break;
            }
            place(m.r,m.c,sidet);
            int score;
            if(lamow()){
                score=winsc-(50-depth);
            }else{
                score=-negam(depth-1,-beta,-alpha,-sidet,1,true);
            }
            undo();
            topmo.push_back({m,score});
            srche++;
            if(score>bssco){
                bssco=score;
                bsmov=m;
                if(verbo){
                    cout<<"[update] depth="<<depth<<" best="<<coost(bsmov.r,bsmov.c)<<" score="<<bssco<<" ("<<srche<<"/"<<total<<")"<<" t="<<(int)elams()<<"ms\n";
                    cout.flush();
                }
            }
            alpha=max(alpha,score);
            if(alpha>=beta){
                break;
            }
        }
        sort(topmo.begin(),topmo.end(),[](auto&a,auto&b){
            return a.second>b.second;
        }
        );
        if((int)topmo.size()>10){
            topmo.resize(10);
        }
        return{bsmov,bssco};
    }
    pair<move0,int>rosrp(int sidet,int depth,int alpha,int beta,vector<pair<move0,int>>&topmo,bool verbo,int threa){
        auto moves=genca(sidet);
        uint8_t ttr=255,ttc=255;
        tt->getbs(ttkey(sidet),ttr,ttc);
        ordmo(moves,sidet,0,ttr,ttc);
        if((int)moves.size()>24){
            moves.resize(24);
        }
        vector<int>scos(moves.size(),-inf);
        atomic<int>nexti{0};
        mutex outmu;
        atomic<int>bssco{-inf};
        atomic<int>bsidx{0};
        struct worke{
            engin eng;
            worke(shared_ptr<tttab>share,bool shatt):eng(16,shatt?share:nullptr){
            }
        };
        vector<unique_ptr<worke>>wwork;
        wwork.reserve(threa);
        for(int i=0;i<threa;i++){
            wwork.emplace_back(make_unique<worke>(this->tt,limit.shatt));
            wwork.back()->eng.cpyfr(*this);
            wwork.back()->eng.limit=this->limit;
            wwork.back()->eng.start=this->start;
            wwork.back()->eng.ddl=this->ddl;
            wwork.back()->eng.stopf.store(false);
            wwork.back()->eng.stats={};
            wwork.back()->eng.ttgen=this->ttgen;
            wwork.back()->eng.cfgtt(this->limit.usepe);
            wwork.back()->eng.tt->seusp(this->limit.usepe);
        }
        auto worfn=[&](int tid){
            worke&w=*wwork[tid];
            while(true){
                int i=nexti.fetch_add(1);
                if(i>=(int)moves.size()){
                    break;
                }
                if(stopf.load()){
                    break;
                }
                if(chrono::steady_clock::now()>=ddl){
                    stopf.store(true);
                    break;
                }
                w.eng.cpyfr(*this);
                w.eng.stopf.store(false);
                w.eng.ttgen=this->ttgen;
                w.eng.cfgtt(this->limit.usepe);
                w.eng.place(moves[i].r,moves[i].c,sidet);
                int sc;
                if(w.eng.lamow()){
                    sc=winsc-(50-depth);
                }else{
                    sc=-w.eng.negam(depth-1,-inf,inf,-sidet,1,true);
                }
                w.eng.undo();
                if(w.eng.stopf.load()){
                    stopf.store(true);
                    break;
                }
                scos[i]=sc;
                int curbe=bssco.load();
                while(sc>curbe&&!bssco.compare_exchange_weak(curbe,sc)){
                }
                if(sc==bssco.load()){
                    bsidx.store(i);
                }
                if(verbo){
                    lock_guard<mutex>lk(outmu);
                    int idx=bsidx.load();
                    cout<<"[par] depth="<<depth<<" done="<<(i+1)<<"/"<<(int)moves.size()<<" move="<<coost(moves[i].r,moves[i].c)<<" score="<<sc<<" best="<<coost(moves[idx].r,moves[idx].c)<<" bestScore="<<bssco.load()<<" t="<<(int)elams()<<"ms\n";
                    cout.flush();
                }
            }
        };
        vector<thread>pool;
        pool.reserve(threa);
        for(int t=0;t<threa;t++){
            pool.emplace_back(worfn,t);
        }
        for(auto&th:pool){
            th.join();
        }
        for(auto&wp:wwork){
            stats.nodes+=wp->eng.stats.nodes;
            stats.qnode+=wp->eng.stats.qnode;
        }
        topmo.clear();
        for(int i=0;i<(int)moves.size();i++){
            if(scos[i]!=-inf){
                topmo.push_back({moves[i],scos[i]});
            }
        }
        sort(topmo.begin(),topmo.end(),[](auto&a,auto&b){
            return a.second>b.second;
        }
        );
        if((int)topmo.size()>10){
            topmo.resize(10);
        }
        int bi=0;
        int bs=-inf;
        for(int i=0;i<(int)moves.size();i++){
            if(scos[i]>bs){
                bs=scos[i];
                bi=i;
            }
        }
        return{moves[bi],bs};
    }
    struct pdent{
        uint32_t pn=1;
        uint32_t dn=1;
        uint8_t br=255,bc=255;
        int depth=0;
        uint16_t gen=0;
        uint32_t lock=0;
    };
    struct pdtab{
        static constexpr uint32_t pninf=1'000'000'000u;
        struct slot{
            uint32_t lock=0;
            uint32_t pn=1,dn=1;
            uint8_t br=255,bc=255;
            uint16_t depth=0;
            uint16_t gen=0;
        };
        vector<slot>t;
        size_t mask=0;
        uint16_t gen=1;
        void inipo(size_t pow2){
            t.assign(pow2,slot{});
            mask=pow2-1;
            gen=1;
        }
        void newsr(){
            gen++;
            if(gen==0){
                gen=1;
            }
        }
        slot*probe(uint64_t k){
            return&t[(size_t)k&mask];
        }
        bool get(uint64_t k,uint32_t&pn,uint32_t&dn,uint8_t&br,uint8_t&bc,uint16_t&depth){
            uint32_t lock=(uint32_t)(k>>32);
            slot*s=probe(k);
            if(s->gen==gen&&s->lock==lock){
                pn=s->pn;
                dn=s->dn;
                br=s->br;
                bc=s->bc;
                depth=s->depth;
                return true;
            }
            return false;
        }
        void put(uint64_t k,uint32_t pn,uint32_t dn,uint8_t br,uint8_t bc,uint16_t depth){
            uint32_t lock=(uint32_t)(k>>32);
            slot*s=probe(k);
            if(s->gen!=gen||depth>=s->depth){
                s->gen=gen;
                s->lock=lock;
                s->pn=pn;
                s->dn=dn;
                s->br=br;
                s->bc=bc;
                s->depth=depth;
            }
        }
    };
    static constexpr uint32_t pninf=1'000'000'000u;
    vector<move0>colsq(int side,int radiu,int cap){
        auto cand=genba(radiu);
        vector<move0>wins;
        wins.reserve(16);
        for(auto&m:cand){
            if(wouwi(m.r,m.c,side)){
                wins.push_back(m);
                if((int)wins.size()>=cap){
                    break;
                }
            }
        }
        return wins;
    }
    vector<move0>colde(int attac){
        bool seen[n*n]{
        };
        vector<move0>out;
        out.reserve(32);
        auto addid=[&](int idx){
            if(idx<0){
                return;
            }
            if(seen[idx]){
                return;
            }
            int r=idx/n;
            int c=idx%n;
            if(board[r][c]!=eempt){
                return;
            }
            seen[idx]=true;
            out.push_back({r,c,0});
        };
        for(int lid=0;lid<shared0::lincn;lid++){
            const auto&cells=shared0::lince[lid];
            int l0=(int)cells.size();
            if(l0<5){
                continue;
            }
            int extle=l0+2;
            int d[17];
            int pos[17];
            d[0]=2;
            pos[0]=-1;
            for(int i=0;i<l0;i++){
                auto[rr,cc]=cells[i];
                int v=board[rr][cc];
                d[i+1]=(v==eempt?0:(v==attac?1:2));
                pos[i+1]=rr*n+cc;
            }
            d[extle-1]=2;
            pos[extle-1]=-1;
            for(int i=0;i+5<=extle;i++){
                if(i+5<=extle){
                    if(d[i]==0&&d[i+1]==1&&d[i+2]==1&&d[i+3]==1&&d[i+4]==0){
                        addid(pos[i]);
                        addid(pos[i+4]);
                    }
                }
                if(i+6<=extle){
                    if(d[i]==0&&d[i+1]==1&&d[i+2]==1&&d[i+3]==0&&d[i+4]==1&&d[i+5]==0){
                        addid(pos[i]);
                        addid(pos[i+3]);
                        addid(pos[i+5]);
                    }
                    if(d[i]==0&&d[i+1]==1&&d[i+2]==0&&d[i+3]==1&&d[i+4]==1&&d[i+5]==0){
                        addid(pos[i]);
                        addid(pos[i+2]);
                        addid(pos[i+5]);
                    }
                }
            }
        }
        for(auto&m:out){
            m.h=poihe(m.r,m.c,-attac)*2+poihe(m.r,m.c,attac)*3;
        }
        sort(out.begin(),out.end(),[](const move0&a,const move0&b){
            return a.h>b.h;
        }
        );
        if((int)out.size()>18){
            out.resize(18);
        }
        return out;
    }
    bool isvcf(int attac,const move0&m){
        if(wouwi(m.r,m.c,attac)){
            return true;
        }
        place(m.r,m.c,attac);
        auto wins=colsq(attac,3,2);
        undo();
        return!wins.empty();
    }
    bool isvct(int attac,const move0&m){
        place(m.r,m.c,attac);
        auto def=colde(attac);
        undo();
        return!def.empty();
    }
    vector<move0>genmo(int attac,int sidet){
        int radiu=(movcn()<10?2:3);
        if(sidet==attac){
            auto cand=genba(radiu);
            vector<move0>moves;
            moves.reserve(32);
            for(auto&m:cand){
                if(wouwi(m.r,m.c,attac)){
                    m.h=winsc;
                    moves.push_back(m);
                    continue;
                }
                if(isvcf(attac,m)){
                    m.h=800'000+poihe(m.r,m.c,attac);
                    moves.push_back(m);
                    continue;
                }
                if(isvct(attac,m)){
                    m.h=300'000+poihe(m.r,m.c,attac);
                    moves.push_back(m);
                }
            }
            sort(moves.begin(),moves.end(),[](const move0&a,const move0&b){
                return a.h>b.h;
            }
            );
            if((int)moves.size()>24){
                moves.resize(24);
            }
            return moves;
        }else{
            int defen=sidet;
            auto cand=genba(radiu);
            vector<move0>win;
            for(auto&m:cand){
                if(wouwi(m.r,m.c,defen)){
                    m.h=winsc;
                    win.push_back(m);
                    if((int)win.size()>=8){
                        break;
                    }
                }
            }
            if(!win.empty()){
                return win;
            }
            auto block=colsq(attac,3,24);
            if(!block.empty()){
                for(auto&m:block){
                    m.h=poihe(m.r,m.c,defen);
                }
                sort(block.begin(),block.end(),[](const move0&a,const move0&b){
                    return a.h>b.h;
                }
                );
                if((int)block.size()>24){
                    block.resize(24);
                }
                return block;
            }
            auto vctbl=colde(attac);
            return vctbl;
        }
    }
    inline uint64_t pdkey(int attac,int sidet) const{
        uint64_t k=hshst;
        k^=(sidet==black?shared0::zside:0ULL);
        k^=(attac==black?0x9e3779b97f4a7c15ULL:0xC2B2AE3D27D4EB4FULL);
        return k;
    }
    struct pnpai{
        uint32_t pn,dn;
    };
    static inline pnpai pn_or(const vector<pnpai>&ch){
        if(ch.empty()){
            return{pninf,0};
        }
        uint32_t pn=pninf;
        uint64_t dnsum=0;
        for(auto&x:ch){
            pn=min(pn,x.pn);
            dnsum+=x.dn;
            if(dnsum>=pninf){
                dnsum=pninf;
                break;
            }
        }
        return{pn,(uint32_t)dnsum};
    }
    static inline pnpai pnand(const vector<pnpai>&ch){
        if(ch.empty()){
            return{pninf,0};
        }
        uint64_t pnsum=0;
        uint32_t dn=pninf;
        for(auto&x:ch){
            pnsum+=x.pn;
            if(pnsum>=pninf){
                pnsum=pninf;
            }
            dn=min(dn,x.dn);
        }
        return{(uint32_t)pnsum,dn};
    }
    int selmp(const vector<pnpai>&cchil,bool isor){
        int best=0;
        if(cchil.empty()){
            return best;
        }
        if(isor){
            uint32_t bspn=cchil[0].pn;
            uint32_t bsdn=cchil[0].dn;
            for(int i=1;i<(int)cchil.size();i++){
                auto&e=cchil[i];
                if(e.pn<bspn||(e.pn==bspn&&e.dn<bsdn)){
                    best=i;
                    bspn=e.pn;
                    bsdn=e.dn;
                }
            }
        }else{
            uint32_t bsdn=cchil[0].dn;
            uint32_t bspn=cchil[0].pn;
            for(int i=1;i<(int)cchil.size();i++){
                auto&e=cchil[i];
                if(e.dn<bsdn||(e.dn==bsdn&&e.pn<bspn)){
                    best=i;
                    bsdn=e.dn;
                    bspn=e.pn;
                }
            }
        }
        return best;
    }
    bool dfpso(int attac,int timeb,uint64_t nodeb,move0&outbe,vector<move0>&outpv){
        if(movst.empty()){
            return false;
        }
        auto saved=ddl;
        auto ssave=start;
        auto savea=limit;
        start=chrono::steady_clock::now();
        ddl=start+chrono::milliseconds(timeb);
        pdtab pd;
        pd.inipo(1u<<20);
        pd.newsr();
        uint64_t local=0;
        function<pair<uint32_t,uint32_t>(int,int,uint32_t,uint32_t,int)>dfpn;
        dfpn=[&](int atk,int stm,uint32_t phi,uint32_t delta,int depth)->pair<uint32_t,uint32_t>{
            local++;
            if((local&4095u)==0u){
                if(chrono::steady_clock::now()>=ddl||local>=nodeb){
                    return{pninf,pninf};
                }
            }
            if(!movst.empty()){
                auto lm=movst.back();
                int lasts=board[lm.r][lm.c];
                if(bbwia(lm.r,lm.c,lasts)){
                    if(lasts==atk){
                        return{0,pninf};
                    }
                    return{pninf,0};
                }
            }
            uint64_t k=pdkey(atk,stm);
            uint32_t pn0,dn0;
            uint8_t br,bc;
            uint16_t d0;
            if(pd.get(k,pn0,dn0,br,bc,d0)){
                if(pn0>=phi||dn0>=delta){
                    return{pn0,dn0};
                }
            }
            bool isor=(stm==atk);
            auto moves=genmo(atk,stm);
            if(moves.empty()){
                pd.put(k,pninf,0,255,255,(uint16_t)depth);
                return{pninf,0};
            }
            vector<pnpai>cchil(moves.size(),{1,1});
            for(int i=0;i<(int)moves.size();i++){
                place(moves[i].r,moves[i].c,stm);
                uint64_t ck=pdkey(atk,-stm);
                uint32_t cpn,cdn;
                uint8_t cbr,cbc;
                uint16_t cd;
                if(pd.get(ck,cpn,cdn,cbr,cbc,cd)){
                    cchil[i]={cpn,cdn};
                }else{
                    cchil[i]={1,1};
                }
                undo();
            }
            auto recno=[&]()->tuple<uint32_t,uint32_t,int>{
                pnpai pn=isor?pn_or(cchil):pnand(cchil);
                int bi=0;
                if(isor){
                    uint32_t bspn=cchil[0].pn;
                    for(int i=1;i<(int)cchil.size();i++){
                        if(cchil[i].pn<bspn){
                            bspn=cchil[i].pn;
                            bi=i;
                        }
                    }
                }
                return{pn.pn,pn.dn,bi};
            };
            auto[pn,dn,bi]=recno();
            while(pn<phi&&dn<delta){
                if(chrono::steady_clock::now()>=ddl||local>=nodeb){
                    break;
                }
                int bschi=selmp(cchil,isor);
                uint32_t phic,ddelt;
                if(isor){
                    phic=min(phi,pn==pninf?pninf:pn+1);
                    uint64_t sumot=0;
                    for(int i=0;i<(int)cchil.size();i++){
                        if(i!=bschi){
                            sumot+=cchil[i].dn;
                            if(sumot>=pninf){
                                sumot=pninf;
                                break;
                            }
                        }
                    }
                    ddelt=(delta>sumot)?(uint32_t)(delta-sumot):1u;
                    if(ddelt==0u){
                        ddelt=1u;
                    }
                }else{
                    uint64_t sumot=0;
                    for(int i=0;i<(int)cchil.size();i++){
                        if(i!=bschi){
                            sumot+=cchil[i].pn;
                            if(sumot>=pninf){
                                sumot=pninf;
                                break;
                            }
                        }
                    }
                    phic=(phi>sumot)?(uint32_t)(phi-sumot):1u;
                    if(phic==0u){
                        phic=1u;
                    }
                    ddelt=min(delta,dn==pninf?pninf:dn+1);
                }
                place(moves[bschi].r,moves[bschi].c,stm);
                auto child=dfpn(atk,-stm,phic,ddelt,depth+1);
                undo();
                cchil[bschi]={child.first,child.second};
                tie(pn,dn,bi)=recno();
            }
            pd.put(k,pn,dn,(uint8_t)moves[bi].r,(uint8_t)moves[bi].c,(uint16_t)depth);
            return{pn,dn};
        };
        auto root=dfpn(attac,attac,pninf,pninf,0);
        bool prove=(root.first==0);
        if(prove){
            uint64_t k=pdkey(attac,attac);
            uint32_t pn,dn;
            uint8_t br,bc;
            uint16_t dep;
            if(pd.get(k,pn,dn,br,bc,dep)&&br!=255){
                outbe={(int)br,(int)bc,0};
            }else{
                prove=false;
            }
            outpv.clear();
            int stm=attac;
            int pplac=0;
            for(int i=0;i<20&&prove;i++){
                uint64_t kk=pdkey(attac,stm);
                uint32_t pp,dd;
                uint8_t r,c;
                uint16_t d;
                if(!pd.get(kk,pp,dd,r,c,d)){
                    break;
                }
                if(r==255||c==255){
                    break;
                }
                if(!inb(r,c)||board[r][c]!=eempt){
                    break;
                }
                place((int)r,(int)c,stm);
                outpv.push_back({(int)r,(int)c,0});
                pplac++;
                if(lamow()){
                    break;
                }
                stm=-stm;
            }
            for(int i=0;i<pplac;i++){
                undo();
            }
        }
        start=ssave;
        ddl=saved;
        limit=savea;
        return prove;
    }
};

namespace termui{
#if defined(_WIN32)
struct tctx{
    HANDLE hin=INVALID_HANDLE_VALUE;
    HANDLE hout=INVALID_HANDLE_VALUE;
    DWORD in_old=0;
    CONSOLE_CURSOR_INFO cur_old{};
    bool cur_ok=false;
    bool ok=false;
    tctx(){
        hin=::GetStdHandle(STD_INPUT_HANDLE);
        hout=::GetStdHandle(STD_OUTPUT_HANDLE);
        if(hin==INVALID_HANDLE_VALUE||hout==INVALID_HANDLE_VALUE){
            return;
        }
        DWORD mode=0;
        if(!::GetConsoleMode(hin,&mode)){
            return;
        }
        in_old=mode;
        DWORD nmode=mode;
        nmode|=ENABLE_MOUSE_INPUT|ENABLE_EXTENDED_FLAGS;
        nmode&=~(DWORD)ENABLE_QUICK_EDIT_MODE;
        if(!::SetConsoleMode(hin,nmode)){
            return;
        }
        CONSOLE_CURSOR_INFO ci{};
        if(::GetConsoleCursorInfo(hout,&ci)){
            cur_old=ci;
            cur_ok=true;
            ci.bVisible=FALSE;
            ::SetConsoleCursorInfo(hout,&ci);
        }
        ok=true;
    }
    ~tctx(){
        if(hin!=INVALID_HANDLE_VALUE){
            ::SetConsoleMode(hin,in_old);
        }
        if(cur_ok&&hout!=INVALID_HANDLE_VALUE){
            ::SetConsoleCursorInfo(hout,&cur_old);
        }
    }
};
static inline void cls(){
    HANDLE hout=::GetStdHandle(STD_OUTPUT_HANDLE);
    if(hout==INVALID_HANDLE_VALUE){
        return;
    }
    CONSOLE_SCREEN_BUFFER_INFO cs{};
    if(!::GetConsoleScreenBufferInfo(hout,&cs)){
        return;
    }
    DWORD cells=(DWORD)(cs.dwSize.X*cs.dwSize.Y);
    DWORD wr=0;
    COORD home{0,0};
    ::FillConsoleOutputCharacterA(hout,' ',cells,home,&wr);
    ::FillConsoleOutputAttribute(hout,cs.wAttributes,cells,home,&wr);
    ::SetConsoleCursorPosition(hout,home);
}
static inline bool waitin(int ms){
    HANDLE hin=::GetStdHandle(STD_INPUT_HANDLE);
    if(hin==INVALID_HANDLE_VALUE){
        return false;
    }
    DWORD t=(ms<0)?INFINITE:(DWORD)ms;
    DWORD r=::WaitForSingleObject(hin,t);
    return r==WAIT_OBJECT_0;
}
static bool redev(int&typ,int&key,int&x,int&y,bool&down){
    typ=0;
    key=0;
    x=0;
    y=0;
    down=false;
    HANDLE hin=::GetStdHandle(STD_INPUT_HANDLE);
    if(hin==INVALID_HANDLE_VALUE){
        return false;
    }
    INPUT_RECORD rec{};
    DWORD nread=0;
    while(true){
        if(!::ReadConsoleInputA(hin,&rec,1,&nread)||nread!=1){
            return false;
        }
        if(rec.EventType==KEY_EVENT){
            const KEY_EVENT_RECORD&ke=rec.Event.KeyEvent;
            if(!ke.bKeyDown){
                continue;
            }
            char ch=ke.uChar.AsciiChar;
            if(ch==0){
                if(ke.wVirtualKeyCode==VK_ESCAPE){
                    typ=1;
                    key=27;
                    return true;
                }
                continue;
            }
            typ=1;
            key=(unsigned char)ch;
            return true;
        }
        if(rec.EventType==MOUSE_EVENT){
            const MOUSE_EVENT_RECORD&me=rec.Event.MouseEvent;
            if(me.dwEventFlags!=0&&me.dwEventFlags!=DOUBLE_CLICK){
                continue;
            }
            if(me.dwButtonState&FROM_LEFT_1ST_BUTTON_PRESSED){
                typ=2;
                x=(int)me.dwMousePosition.X+1;
                y=(int)me.dwMousePosition.Y+1;
                down=true;
                return true;
            }
            continue;
        }
    }
}
static inline bool mapxy(int x,int y,int&outr,int&outc){
    static constexpr int bx=5;
    static constexpr int by=2;
    static constexpr int cw=3;
    int dx=x-bx;
    int dy=y-by;
    if(dy<0||dy>=n){
        return false;
    }
    if(dx<0||dx>=cw*n){
        return false;
    }
    outc=dx/cw;
    outr=dy;
    return true;
}
static void draw(const engin&eng,int human,int ai,int tomov){
    cls();
    eng.prbop();
    cout<<"Turn: "<<(tomov==black?'X':'O')<<" ("<<(tomov==black?"Black":"White")<<")";
    if(tomov==human){
        cout<<"  [You]";
    }else{
        cout<<"  [AI]";
    }
    cout<<char(10);
    cout<<"Click to move. Keys: q quit"<<char(10);
    cout<<"You: "<<(human==black?'X':'O')<<"  AI: "<<(ai==black?'X':'O')<<char(10);
    cout.flush();
}
static int run(engin&eng,const srchl&lim,int human,int ai){
    tctx ctx;
    if(!ctx.ok){
        cout<<"[tui] need Windows Console/Terminal with mouse input (Quick Edit disabled)."<<char(10);
        return 0;
    }
    int tomov=black;
    while(true){
        if(eng.movcn()>=n*n){
            draw(eng,human,ai,tomov);
            cout<<char(10)<<"Draw (board full)."<<char(10);
            cout.flush();
            break;
        }
        draw(eng,human,ai,tomov);
        if(tomov==human){
            while(true){
                int typ,key,x,y;
                bool down=false;
                if(!waitin(-1)){
                    continue;
                }
                if(!redev(typ,key,x,y,down)){
                    continue;
                }
                if(typ==1){
                    if(key=='q'||key=='Q'||key==27){
                        return 0;
                    }
                    continue;
                }
                if(typ==2&&down){
                    int r,c;
                    if(!mapxy(x,y,r,c)){
                        continue;
                    }
                    if(!eng.isleg(r,c)){
                        continue;
                    }
                    eng.place(r,c,human);
                    break;
                }
            }
            if(eng.lamow()){
                draw(eng,human,ai,tomov);
                cout<<char(10)<<"You win!"<<char(10);
                cout.flush();
                break;
            }
        }else{
            cout<<char(10)<<"AI thinking (<= "<<lim.timms<<" ms)..."<<char(10);
            cout.flush();
            move0 best=eng.think(ai,lim,false);
            eng.place(best.r,best.c,ai);
            if(eng.lamow()){
                draw(eng,human,ai,tomov);
                cout<<char(10)<<"AI wins!"<<char(10);
                cout.flush();
                break;
            }
        }
        tomov=-tomov;
    }
    return 0;
}
#else
struct tctx{
    termios old{};
    bool ok=false;
    tctx(){
        if(!::isatty(0)){
            return;
        }
        if(::tcgetattr(0,&old)!=0){
            return;
        }
        termios raw=old;
        ::cfmakeraw(&raw);
        raw.c_oflag|=OPOST;
        if(::tcsetattr(0,TCSANOW,&raw)!=0){
            return;
        }
        ok=true;
        cout<<char(27)<<"[?25l";
        cout<<char(27)<<"[?1000h"<<char(27)<<"[?1006h";
        cout.flush();
    }
    ~tctx(){
        if(!ok){
            return;
        }
        ::tcsetattr(0,TCSANOW,&old);
        cout<<char(27)<<"[?1000l"<<char(27)<<"[?1006l";
        cout<<char(27)<<"[?25h";
        cout.flush();
    }
};
static inline void cls(){
    cout<<char(27)<<"[2J"<<char(27)<<"[H";
}
static inline bool waitin(int ms){
    fd_set rf;
    FD_ZERO(&rf);
    FD_SET(0,&rf);
    timeval tv;
    timeval*ptv=nullptr;
    if(ms>=0){
        tv.tv_sec=ms/1000;
        tv.tv_usec=(ms%1000)*1000;
        ptv=&tv;
    }
    int r=::select(1,&rf,nullptr,nullptr,ptv);
    return r>0&&FD_ISSET(0,&rf);
}
static inline bool rdch(char&ch){
    ssize_t r=::read(0,&ch,1);
    return r==1;
}
static inline bool rdch_tmo(char&ch,int ms){
    if(!waitin(ms)){
        return false;
    }
    return rdch(ch);
}
static bool rdmou(int&x,int&y,bool&down){
    string cur;
    int fld=0;
    string bx,by;
    char ch=0;
    while(true){
        if(!rdch(ch)){
            return false;
        }
        if(isdigit((unsigned char)ch)){
            cur.push_back(ch);
            continue;
        }
        if(ch==';'){
            if(fld==1){
                bx=cur;
            }else{
                if(fld==2){
                    by=cur;
                }
            }
            cur.clear();
            fld++;
            continue;
        }
        if(ch=='M'||ch=='m'){
            if(fld==1){
                bx=cur;
            }else{
                if(fld>=2){
                    by=cur;
                }
            }
            if(bx.empty()||by.empty()){
                return false;
            }
            x=atoi(bx.c_str());
            y=atoi(by.c_str());
            down=(ch=='M');
            return true;
        }
        return false;
    }
}
static bool redev(int&typ,int&key,int&x,int&y,bool&down){
    typ=0;
    key=0;
    x=0;
    y=0;
    down=false;
    char ch=0;
    if(!rdch(ch)){
        return false;
    }
    if(ch!=27){
        typ=1;
        key=(unsigned char)ch;
        return true;
    }
    char c1=0;
    if(!rdch_tmo(c1,20)){
        typ=1;
        key=27;
        return true;
    }
    if(c1!='['){
        typ=1;
        key=27;
        return true;
    }
    char c2=0;
    if(!rdch_tmo(c2,20)){
        typ=1;
        key=27;
        return true;
    }
    if(c2!='<'){
        typ=1;
        key=27;
        return true;
    }
    int mx=0,my=0;
    bool dn=false;
    if(!rdmou(mx,my,dn)){
        return false;
    }
    typ=2;
    x=mx;
    y=my;
    down=dn;
    return true;
}
static inline bool mapxy(int x,int y,int&outr,int&outc){
    static constexpr int bx=5;
    static constexpr int by=2;
    static constexpr int cw=3;
    int dx=x-bx;
    int dy=y-by;
    if(dy<0||dy>=n){
        return false;
    }
    if(dx<0||dx>=cw*n){
        return false;
    }
    outc=dx/cw;
    outr=dy;
    return true;
}
static void draw(const engin&eng,int human,int ai,int tomov){
    cls();
    eng.prbop();
    cout<<"Turn: "<<(tomov==black?'X':'O')<<" ("<<(tomov==black?"Black":"White")<<")";
    if(tomov==human){
        cout<<"  [You]";
    }else{
        cout<<"  [AI]";
    }
    cout<<char(10);
    cout<<"Click to move. Keys: q quit"<<char(10);
    cout<<"You: "<<(human==black?'X':'O')<<"  AI: "<<(ai==black?'X':'O')<<char(10);
    cout.flush();
}
static int run(engin&eng,const srchl&lim,int human,int ai){
    tctx ctx;
    if(!ctx.ok){
        cout<<"[tui] need a TTY terminal with xterm mouse reporting."<<char(10);
        return 0;
    }
    int tomov=black;
    while(true){
        if(eng.movcn()>=n*n){
            draw(eng,human,ai,tomov);
            cout<<char(10)<<"Draw (board full)."<<char(10);
            cout.flush();
            break;
        }
        draw(eng,human,ai,tomov);
        if(tomov==human){
            while(true){
                int typ,key,x,y;
                bool down=false;
                if(!waitin(-1)){
                    continue;
                }
                if(!redev(typ,key,x,y,down)){
                    continue;
                }
                if(typ==1){
                    if(key=='q'||key=='Q'){
                        return 0;
                    }
                    continue;
                }
                if(typ==2&&down){
                    int r,c;
                    if(!mapxy(x,y,r,c)){
                        continue;
                    }
                    if(!eng.isleg(r,c)){
                        continue;
                    }
                    eng.place(r,c,human);
                    break;
                }
            }
            if(eng.lamow()){
                draw(eng,human,ai,tomov);
                cout<<char(10)<<"You win!"<<char(10);
                cout.flush();
                break;
            }
        }else{
            cout<<char(10)<<"AI thinking (<= "<<lim.timms<<" ms)..."<<char(10);
            cout.flush();
            move0 best=eng.think(ai,lim,false);
            eng.place(best.r,best.c,ai);
            if(eng.lamow()){
                draw(eng,human,ai,tomov);
                cout<<char(10)<<"AI wins!"<<char(10);
                cout.flush();
                break;
            }
        }
        tomov=-tomov;
    }
    return 0;
}
#endif
}
static inline string trmcp(string s){
    auto is_ws=[](unsigned char ch){
        return isspace(ch);
    };
    while(!s.empty()&&is_ws((unsigned char)s.front())){
        s.erase(s.begin());
    }while(!s.empty()&&is_ws((unsigned char)s.back())){
        s.pop_back();
    }
    return s;
}
static bool prsan(const string&line,int&outr,int&outc){
    string s=trmcp(line);
    if(s.empty()){
        return false;
    }
    {
        stringstream ss(s);
        int r,c;
        if((ss>>r>>c)){
            outr=r-1;
            outc=c-1;
            return true;
        }
    }
    string t;
    for(char ch:s){
        if(ch!=' '&&ch!='\t'&&ch!=','&&ch!=';'){
            t.push_back(ch);
        }
    }
    if(t.size()<2){
        return false;
    }
    for(char&ch:t){
        ch=(char)toupper((unsigned char)ch);
    }
    auto iscol=[](char ch){
        return ch>='A'&&ch<='O';
    };
    auto isdig=[](char ch){
        return ch>='0'&&ch<='9';
    };
    int col=-1;
    int num=-1;
    if(iscol(t[0])){
        col=t[0]-'A';
        string digit=t.substr(1);
        if(digit.empty()){
            return false;
        }
        for(char ch:digit){
            if(!isdig(ch)){
                return false;
            }
        }
        num=stoi(digit);
    }else{
        if(isdig(t[0])){
            int i=0;
            while(i<(int)t.size()&&isdig(t[i])){
                i++;
            }
            if(i==0||i>=(int)t.size()){
                return false;
            }
            string digit=t.substr(0,i);
            char ch=t[i];
            if(!iscol(ch)){
                return false;
            }
            col=ch-'A';
            num=stoi(digit);
        }else{
            return false;
        }
    }
    outr=num-1;
    outc=col;
    return true;
}
int main(int argc,char**argv){
    ios::sync_with_stdio(false);
    cin.tie(&cout);
    srchl lim;
    lim.timms=10'000;
    bool aibla=false,aiwhi=false;
    bool tui=false;
    for(int i=1;i<argc;i++){
        string a=argv[i];
        if(!a.empty()&&all_of(a.begin(),a.end(),::isdigit)){
            int t=atoi(a.c_str());
            if(t>=200){
                lim.timms=t;
            }
            continue;
        }
        if(a=="--tui"||a=="--click"){
            tui=true;
            continue;
        }
        if(a.rfind("--tt-mb=",0)==0){
            long long mb=atoll(a.substr(8).c_str());
            if(mb>=8){
                lim.tt_mb=(size_t)mb;
            }
        }else{
            if(a=="--no-shared-tt"){
                lim.shatt=false;
            }else{
                if(a=="--shared-tt"){
                    lim.shatt=true;
                }else{
                    if(a=="--no-pext"){
                        lim.usepe=false;
                    }else{
                        if(a=="--pext"){
                            lim.usepe=true;
                        }else{
                            if(a=="--ai-black"){
                                aibla=true;
                            }else{
                                if(a=="--ai-white"){
                                    aiwhi=true;
                                }else{
                                    if(a.rfind("--threads=",0)==0){
                                        lim.threa=atoi(a.substr(10).c_str());
                                    }else{
                                        if(a=="--no-null"){
                                            lim.usenu=false;
                                        }else{
                                            if(a=="--no-dfpn"){
                                                lim.usedf=false;
                                            }else{
                                                if(a=="--no-book"){
                                                    lim.usebo=false;
                                                }else{
                                                    if(a=="--book"||a.rfind("--book=",0)==0){
                                                        lim.usebo=true;
                                                    }else{
                                                        if(a.rfind("--book-ply=",0)==0){
                                                            lim.boply=atoi(a.substr(11).c_str());
                                                            lim.boply=(lim.boply<=4?4:6);
                                                        }else{
                                                            if(a=="--book-nosym"){
                                                                lim.bosym=false;
                                                            }else{
                                                                if(a=="--book-sym"){
                                                                    lim.bosym=true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    int ai=white;
    int human=black;
    if(aibla){
        ai=black;
        human=white;
    }else{
        if(aiwhi){
            ai=white;
            human=black;
        }
    }
    shared_ptr<tttab>sshar;
    if(lim.shatt){
        sshar=make_shared<tttab>();
        sshar->inimb(lim.tt_mb);
        sshar->seusp(lim.usepe);
    }
    engin eng(lim.tt_mb,sshar);
    eng.cfgtt(lim.usepe);
    std::shared_ptr<opnbo>book;
    bool booko=false;
    if(lim.usebo){
        book=std::make_shared<opnbo>();
        booko=book->lodbu(lim.boply,true);
        if(!booko){
            book.reset();
        }
    }
    eng.seopb(book);
    if(tui){
        return termui::run(eng,lim,human,ai);
    }
    cout<<"Gomoku 15x15 (No forbidden moves)\n";
    cout<<"Columns: A..O, Rows: 1..15\n";
    cout<<"AI time limit per move: "<<lim.timms<<" ms\n";
    int threa=lim.threa;
    if(threa<=0){
        threa=(int)thread::hardware_concurrency();
    }
    if(threa<=0){
        threa=1;
    }
    threa=max(1,min(threa,16));
    cout<<"Threads: "<<threa<<" (use --threads=N)\n";
    cout<<"TT: "<<lim.tt_mb<<" MB, "<<(lim.shatt?"shared":"per-thread")<<", ways=4, pext="<<(eng.ttpeo()?"on":"off")<<"\n";
    cout<<"Book: "<<(booko?"on":"off")<<" (ply="<<lim.boply<<", symmetry=on)\n";
    if(booko){
        cout<<"Book prefixes: "<<book->pfxcn()<<"\n";
    }
    cout<<"Input: '8 8' or 'H8' or '8H'\n";
    cout<<"You are "<<(human==black?'X':'O')<<" ("<<(human==black?"Black":"White")<<")\n";
    cout<<"AI is  "<<(ai==black?'X':'O')<<" ("<<(ai==black?"Black":"White")<<")\n";
    cout<<"Options: --ai-black / --ai-white / --threads=N / --tt-mb=MB / --shared-tt / --no-shared-tt / --pext / --no-pext / --no-null / --no-dfpn"<<" / --book / --book-ply=4|6 / --no-book\n\n";
    eng.prbop();
    int tomov=black;
    while(true){
        if(eng.movcn()>=n*n){
            cout<<"\nDraw (board full).\n";
            break;
        }
        if(tomov==human){
            while(true){
                cout<<"\nYour move: ";
                cout.flush();
                string line;
                if(!getline(cin,line)){
                    return 0;
                }
                line=trmcp(line);
                if(line.empty()){
                    continue;
                }
                int r,c;
                if(!prsan(line,r,c)){
                    cout<<"Cannot parse. Examples: 8 8 / H8 / 8H\n";
                    continue;
                }
                if(!inb(r,c)){
                    cout<<"Out of bounds.\n";
                    continue;
                }
                if(!eng.isleg(r,c)){
                    cout<<"Illegal (occupied).\n";
                    continue;
                }
                eng.place(r,c,human);
                break;
            }
            eng.prbop();
            if(eng.lamow()){
                cout<<"\nYou win!\n";
                break;
            }
        }else{
            cout<<"\nAI thinking (<= "<<lim.timms<<" ms)...\n";
            cout.flush();
            move0 best=eng.think(ai,lim,true);
            eng.place(best.r,best.c,ai);
            cout<<"\nAI plays: "<<eng.coost(best.r,best.c)<<"\n";
            eng.prbop();
            if(eng.lamow()){
                cout<<"\nAI wins!\n";
                break;
            }
        }
        tomov=-tomov;
    }
    return 0;
}
